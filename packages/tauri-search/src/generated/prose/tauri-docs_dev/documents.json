[{"id":"prose_docs_architecture_md","title":"The Tauri Architecture","headings":["Introduction","What Tauri is NOT","Major Components","External Crates","Additional tooling","Tauri Plugins ","Workflows","License"],"subHeadings":["Tauri Core ","Tauri Tooling",[{"content":"TAO","type":"text"}],[{"content":"WRY","type":"text"}],[{"content":"tauri","type":"text"},{"content":"-hotkey","type":"text"},{"content":"-rs","type":"text"}],[{"content":"binary","type":"text"},{"content":"-releases","type":"text"}],[{"content":"tauri","type":"text"},{"content":"-action","type":"text"}],[{"content":"create","type":"text"},{"content":"-pull","type":"text"},{"content":"-request","type":"text"}],[{"content":"vue","type":"text"},{"content":"-cli","type":"text"},{"content":"-plugin","type":"text"},{"content":"-tauri","type":"text"}],[{"content":"tauri","type":"text"},{"content":"-vscode","type":"text"}],"What does the Development flow look like","What does the Release flow look like","What does the End","What does the Updating flow look like"],"code":[null],"text":"# The Tauri Architecture ## Introduction Tauri is a polyglot and generic toolkit\nthat is very composable and allows engineers to make a wide variety of\napplications. It is used for building applications for Desktop Computers using a\ncombination of Rust tools and HTML rendered in a Webview. Apps built with Tauri\ncan ship with any number of pieces of an optional JS API / Rust API so that\nwebviews can control the system via message passing. In fact, developers can\nextend the default API with their own functionality and bridge the Webview and\nRust-based backend easily. Tauri apps can have custom menus and have tray-type\ninterfaces. They can be updated, and are managed by the user's operating system\nas expected. They are very small, because they use the OS's webview. They do not\nship a runtime, since the final binary is compiled from Rust. This makes the\nreversing of Tauri apps not a trivial task. ## What Tauri is NOT - Tauri is not\na lightweight kernel wrapper...instead it directly uses [WRY](#wry) and\n[TAO](#tao) to do the heavy-lifting in making system calls to the OS. - Tauri is\nnot a VM or virtualized environment...instead it is an application toolkit that\nallows making Webview OS applications. ## Major Components The following section\nbriefly describes the roles of the various parts of Tauri. ### Tauri Core\n[STABLE RUST] ####\n[tauri](https://github.com/tauri-apps/tauri/tree/dev/core/tauri) This is the\nmajor crate that holds everything together. It brings the runtimes, macros,\nutilities and API into one final product. It reads the `tauri.conf.json` file at\ncompile time in order to bring in features and undertake actual configuration of\nthe app (and even the `Cargo.toml` file in the project's folder). It handles\nscript injection (for polyfills / prototype revision) at runtime, hosts the API\nfor systems interaction, and even manages updating. ####\n[tauri-build](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-build)\nApply the macros at build-time in order to rig some special features needed by\n`cargo`. ####\n[tauri-codegen](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-codegen)\n- Embed, hash, and compress assets, including icons for the app as well as the\nsystem-tray. - Parse `tauri.conf.json` at compile time and generate the Config\nstruct. ####\n[tauri-macros](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-macros)\nCreate macros for the context, handler, and commands by leveraging the\n`tauri-codegen` crate. ####\n[tauri-runtime](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime)\nThis is the glue layer between tauri itself and lower level webview libraries.\n####\n[tauri-runtime-wry](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime-wry)\nThis crate opens up direct systems-level interactions specifically for WRY, such\nas printing, monitor detection, and other windowing related tasks.\n`tauri-runtime` implementation for WRY. ####\n[tauri-utils](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-utils)\nThis is common code that is reused in many places and offers useful utilities\nlike parsing configuration files, detecting platform triples, injecting the CSP,\nand managing assets. ### Tauri Tooling ####\n[api](https://github.com/tauri-apps/tauri/tree/dev/tooling/api) [TS -> JS] A\ntypescript library that creates `cjs` and `esm` Javascript endpoints for you to\nimport into your Frontend framework so that the Webview can call and listen to\nbackend activity. We also ship the pure typescript, because for some frameworks\nthis is more optimal. It uses the message passing of webviews to their hosts.\n#### [bundler](https://github.com/tauri-apps/tauri/tree/dev/tooling/bundler)\n[RUST / SHELL] The bundler is a library that builds a Tauri App for the platform\ntriple it detects / is told. At the moment it currently supports macOS, Windows\nand Linux - but in the near future will support mobile platforms as well. May be\nused outside of Tauri projects. ####\n[cli.js](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.js) [JS]\nWritten in Typescript and packaged such that it can be used with `npm`, `pnpm`,\nand `yarn`, this library provides a node.js runner for common tasks when using\nTauri, like `yarn tauri dev`. For the most part it is a wrapper around\n[cli.rs](https://github.com/tauri-apps/tauri/blob/dev/tooling/cli). ####\n[cli.rs](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli) [RUST] This\nrust executable provides the full interface to all of the required activities\nfor which the CLI is required. It will run on macOS, Windows, and Linux. ####\n[create-tauri-app](https://github.com/tauri-apps/tauri/tree/dev/tooling/create-tauri-app)\n[JS] This is a toolkit that will enable engineering teams to rapidly scaffold\nout a new tauri-apps project using the frontend framework of their choice (as\nlong as it has been configured). ## External Crates The Tauri-Apps organisation\nmaintains two \"upstream\" crates from Tauri, namely TAO for creating and managing\napplication windows, and WRY for interfacing with the Webview that lives within\nthe window. ### [TAO](https://github.com/tauri-apps/tao) Cross-platform\napplication window creation library in Rust that supports all major platforms\nlike Windows, macOS, Linux, iOS and Android. Written in Rust, it is a fork of\n[winit](https://github.com/rust-windowing/winit) that we have extended for our\nown needs like menu bar and system tray. ###\n[WRY](https://github.com/tauri-apps/wry) WRY is a cross-platform WebView\nrendering library in Rust that supports all major desktop platforms like\nWindows, macOS, and Linux. Tauri uses WRY as the abstract layer responsible to\ndetermine which webview is used (and how interactions are made). ###\n[tauri-hotkey-rs](https://github.com/tauri-apps/tauri-hotkey-rs) We needed to\nfix hotkey to work on all platforms, because upstream was not being responsive.\n## Additional tooling ###\n[binary-releases](https://github.com/tauri-apps/binary-releases) This is the\ndelivery mechanism for tauri prebuilt binaries: currently the cli.rs (used by\ncli.js) and rustup binaries (used by the deps install command of cli.js). These\nartifacts are automatically created on release. ###\n[tauri-action](https://github.com/tauri-apps/tauri-action) This is a github\nworkflow that builds tauri binaries for all platforms. It is not the fastest out\nthere, but it gets the job done and is highly configurable. Even allowing you to\ncreate a (very basic) tauri app even if tauri is not setup. ###\n[create-pull-request](https://github.com/tauri-apps/create-pull-request) Because\nthis is a very risky (potentially destructive) github action, we forked it in\norder to have strong guarantees that the code we think is running is actually\nthe code that is running. ###\n[vue-cli-plugin-tauri](https://github.com/tauri-apps/vue-cli-plugin-tauri) This\nplugin allows you to very quickly install tauri in a vue-cli project. ###\n[tauri-vscode](https://github.com/tauri-apps/tauri-vscode) This project enhances\nthe VS Code interface with several nice-to-have features. ## Tauri Plugins\n[documentation](https://tauri.studio/en/docs/guides/plugin) Generally speaking,\nplugins are authored by third parties (even though there may be official,\nsupported plugins). A plugin generally does 3 things: 1. It provides rust code\nto do \"something\". 2. It provides interface glue to make it easy to integrate\ninto an app. 3. It provides a JS API for interfacing with the rust code. Here\nare several examples of Tauri Plugins: -\nhttps://github.com/tauri-apps/tauri-plugin-sql -\nhttps://github.com/tauri-apps/tauri-plugin-stronghold -\nhttps://github.com/tauri-apps/tauri-plugin-authenticator ## Workflows ### What\ndoes the Development flow look like? A developer must first install the\nprerequisite toolchains for creating a Tauri app. At the very least this will\nentail installing rust & cargo, and most likely also a modern version of node.js\nand potentially another package manager. Some platforms may also require other\ntooling and libraries, but this has been documented carefully in the respective\nplatform docs. Because of the many ways to build front-ends, we will stick with\na common node.js based approach for development. (Note: Tauri does not by\ndefault ship a node.js runtime.) The easiest way to do this is to run the\nfollowing: ``` npx create-tauri-app ``` Which will ask you a bunch of questions\nabout the framework you want to install and then create everything you need in a\nsingle folder - some via the placement of template files and some through normal\ninstallation procedures of your framework. > If you don't use this process, you\nwill have to manually install the tauri cli, initialise tauri and manually\nconfigure the `tauri.conf.json` file. Once everything is installed, you can run:\n``` yarn tauri dev -or- npm run tauri dev ``` This will do several things: 1.\nstart the JS Framework devserver 2. begin the long process of downloading and\ncompiling the rust libraries 3. open an application window with devtools enabled\n4. keep a long-lived console alive If you change your HTML/CSS/TS/JS, your\nframework devserver should give you its best shot at instant hot module\nreloading and you will see the changes instantly. If you modify your rust code\nor anything in the Cargo.toml, the window will close while rust recompiles. When\nfinished it will reload. If you need to get deeper insight into your current\nproject, or triage requires investigation of installed components, just run: ```\nyarn tauri info ``` ### What does the Release flow look like? The release flow\nbegins with proper configuration in the `tauri.conf.json` file. In this file,\nthe developer can configure not only the basic behaviour of the application\n(like window size and decoration), they can also provide settings for signing\nand updating. Depending upon the operating system that the developer (or CI) is\nbuilding the application on, there will be an app built for them for that\nsystem. (Cross compilation is not currently available, however there is an\nofficial [GitHub Action](https://github.com/tauri-apps/tauri-action) that can be\nused to build for all platforms.) To kick off this process, just: ``` yarn tauri\nbuild ``` After some time, the process will end and you can see the results in\nthe `./src-tauri/target/release` folder. ### What does the End-User flow look\nlike? End users will be provided with binaries in ways that are appropriate for\ntheir systems. Whether macOS, Linux, or Windows, direct download or store\ninstallations - they will be able to follow procedures for installing and\nremoving that they are used to. ### What does the Updating flow look like? When\na new version is ready, the developer publishes the new signed artifacts to a\nserver (that they have configured within `tauri.conf.json`). The application can\npoll this server to see if there is a new release. When there is a new release,\nthe user is prompted to update. The application update is downloaded, verified\n(checksum & signature), updated, closed, and restarted. ## License Tauri itself\nis licensed under MIT or Apache-2.0. If you repackage it and modify any source\ncode, it is your responsibility to verify that you are complying with all\nupstream licenses. Tauri is provided AS-IS with no explicit claim for\nsuitability for any purpose. Here you may peruse our [Software Bill of\nMaterials](https://app.fossa.com/projects/git%2Bgithub.com%2Ftauri-apps%2Ftauri).","url":"https://tauri.studio/docs/architecture"},{"id":"prose_docs_faq_md","title":"Frequently Asked Questions","headings":["error"],"subHeadings":[],"code":[null],"text":"## error: could not find native static libraryWebView2LoaderStatic, perhaps an\n-L flag is missing? The WebView2 crate build pipeline requires `NuGet` to have a\n`PackageSource` to install the `Microsoft.Web.WebView2` package. If you have\nnever used `NuGet` before, you might need to create a file named `NuGet.Config`\non `%APPDATA%/NuGet` folder, with the following contents: ``` ``` This\nconfiguration enables the default `NuGet` registry.","url":"https://tauri.studio/docs/faq"},{"id":"prose_docs_about_architecture_md","title":"The Tauri Architecture","area":"about","section":"about","headings":["What does the Release flow look like"],"subHeadings":[],"code":[null],"text":"# The Tauri Architecture ## Introduction Tauri is a polyglot and generic toolkit\nthat is very composable and allows engineers to make a wide variety of\napplications. It is used for building applications for Desktop Computers using a\ncombination of Rust tools and HTML rendered in a Webview. Apps built with Tauri\ncan ship with any number of pieces of an optional JS API / Rust API so that\nwebviews can control the system via message passing. In fact, developers can\nextend the default API with their own functionality and bridge the Webview and\nRust-based backend easily. Tauri apps can have custom menus and have tray-type\ninterfaces. They can be updated, and are managed by the user's operating system\nas expected. They are very small, because they use the OS's webview. They do not\nship a runtime, since the final binary is compiled from Rust. This makes the\nreversing of Tauri apps not a trivial task. ## What Tauri is NOT - Tauri is not\na lightweight kernel wrapper...instead it directly uses [WRY](#wry) and\n[TAO](#tao) to do the heavy-lifting in making system calls to the OS. - Tauri is\nnot a VM or virtualized environment...instead it is an application toolkit that\nallows making Webview OS applications. ## Major Components The following section\nbriefly describes the roles of the various parts of Tauri. ### Tauri Core\n[STABLE RUST] ####\n[tauri](https://github.com/tauri-apps/tauri/tree/dev/core/tauri) This is the\nmajor crate that holds everything together. It brings the runtimes, macros,\nutilities and API into one final product. It reads the `tauri.conf.json` file at\ncompile time in order to bring in features and undertake actual configuration of\nthe app (and even the `Cargo.toml` file in the project's folder). It handles\nscript injection (for polyfills / prototype revision) at runtime, hosts the API\nfor systems interaction, and even manages updating. ####\n[tauri-build](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-build)\nApply the macros at build-time in order to rig some special features needed by\n`cargo`. ####\n[tauri-codegen](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-codegen)\n- Embed, hash, and compress assets, including icons for the app as well as the\nsystem-tray. - Parse `tauri.conf.json` at compile time and generate the Config\nstruct. ####\n[tauri-macros](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-macros)\nCreate macros for the context, handler, and commands by leveraging the\n`tauri-codegen` crate. ####\n[tauri-runtime](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime)\nThis is the glue layer between tauri itself and lower level webview libraries.\n####\n[tauri-runtime-wry](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-runtime-wry)\nThis crate opens up direct systems-level interactions specifically for WRY, such\nas printing, monitor detection, and other windowing related tasks.\n`tauri-runtime` implementation for WRY. ####\n[tauri-utils](https://github.com/tauri-apps/tauri/tree/dev/core/tauri-utils)\nThis is common code that is reused in many places and offers useful utilities\nlike parsing configuration files, detecting platform triples, injecting the CSP,\nand managing assets. ### Tauri Tooling ####\n[api](https://github.com/tauri-apps/tauri/tree/dev/tooling/api) [TS -> JS] A\ntypescript library that creates `cjs` and `esm` Javascript endpoints for you to\nimport into your Frontend framework so that the Webview can call and listen to\nbackend activity. We also ship the pure typescript, because for some frameworks\nthis is more optimal. It uses the message passing of webviews to their hosts.\n#### [bundler](https://github.com/tauri-apps/tauri/tree/dev/tooling/bundler)\n[RUST / SHELL] The bundler is a library that builds a Tauri App for the platform\ntriple it detects / is told. At the moment it currently supports macOS, Windows\nand Linux - but in the near future will support mobile platforms as well. May be\nused outside of Tauri projects. ####\n[cli.js](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli.js) [JS]\nWritten in Typescript and packaged such that it can be used with `npm`, `pnpm`,\nand `yarn`, this library provides a node.js runner for common tasks when using\nTauri, like `yarn tauri dev`. For the most part it is a wrapper around\n[cli.rs](https://github.com/tauri-apps/tauri/blob/dev/tooling/cli). ####\n[cli.rs](https://github.com/tauri-apps/tauri/tree/dev/tooling/cli) [RUST] This\nrust executable provides the full interface to all of the required activities\nfor which the CLI is required. It will run on macOS, Windows, and Linux. ####\n[create-tauri-app](https://github.com/tauri-apps/tauri/tree/dev/tooling/create-tauri-app)\n[JS] This is a toolkit that will enable engineering teams to rapidly scaffold\nout a new tauri-apps project using the frontend framework of their choice (as\nlong as it has been configured). # External Crates The Tauri-Apps organisation\nmaintains two \"upstream\" crates from Tauri, namely TAO for creating and managing\napplication windows, and WRY for interfacing with the Webview that lives within\nthe window. ## [TAO](https://github.com/tauri-apps/tao) Cross-platform\napplication window creation library in Rust that supports all major platforms\nlike Windows, macOS, Linux, iOS and Android. Written in Rust, it is a fork of\n[winit](https://github.com/rust-windowing/winit) that we have extended for our\nown needs like menu bar and system tray. ##\n[WRY](https://github.com/tauri-apps/wry) WRY is a cross-platform WebView\nrendering library in Rust that supports all major desktop platforms like\nWindows, macOS, and Linux. Tauri uses WRY as the abstract layer responsible to\ndetermine which webview is used (and how interactions are made). ##\n[tauri-hotkey-rs](https://github.com/tauri-apps/tauri-hotkey-rs) We needed to\nfix hotkey to work on all platforms, because upstream was not being responsive.\n# Additional tooling ##\n[binary-releases](https://github.com/tauri-apps/binary-releases) This is the\ndelivery mechanism for tauri prebuilt binaries: currently the cli.rs (used by\ncli.js) and rustup binaries (used by the deps install command of cli.js). These\nartifacts are automatically created on release. ##\n[tauri-action](https://github.com/tauri-apps/tauri-action) This is a github\nworkflow that builds tauri binaries for all platforms. It is not the fastest out\nthere, but it gets the job done and is highly configurable. Even allowing you to\ncreate a (very basic) tauri app even if tauri is not setup. ##\n[create-pull-request](https://github.com/tauri-apps/create-pull-request) Because\nthis is a very risky (potentially destructive) github action, we forked it in\norder to have strong guarantees that the code we think is running is actually\nthe code that is running. ##\n[vue-cli-plugin-tauri](https://github.com/tauri-apps/vue-cli-plugin-tauri) This\nplugin allows you to very quickly install tauri in a vue-cli project. ##\n[tauri-vscode](https://github.com/tauri-apps/tauri-vscode) This project enhances\nthe VS Code interface with several nice-to-have features. # Tauri Plugins\n[documentation](https://tauri.studio/en/docs/guides/plugin) Generally speaking,\nplugins are authored by third parties (even though there may be official,\nsupported plugins). A plugin generally does 3 things: 1. It provides rust code\nto do \"something\". 2. It provides interface glue to make it easy to integrate\ninto an app. 3. It provides a JS API for interfacing with the rust code. Here\nare several examples of Tauri Plugins: -\nhttps://github.com/tauri-apps/tauri-plugin-sql -\nhttps://github.com/tauri-apps/tauri-plugin-stronghold -\nhttps://github.com/tauri-apps/tauri-plugin-authenticator # Workflows ## What\ndoes the Development flow look like? A developer must first install the\nprerequisite toolchains for creating a Tauri app. At the very least this will\nentail installing rust & cargo, and most likely also a modern version of node.js\nand potentially another package manager. Some platforms may also require other\ntooling and libraries, but this has been documented carefully in the respective\nplatform docs. Because of the many ways to build front-ends, we will stick with\na common node.js based approach for development. (Note: Tauri does not by\ndefault ship a node.js runtime.) The easiest way to do this is to run the\nfollowing: ``` npx create-tauri-app ``` Which will ask you a bunch of questions\nabout the framework you want to install and then create everything you need in a\nsingle folder - some via the placement of template files and some through normal\ninstallation procedures of your framework. > If you don't use this process, you\nwill have to manually install the tauri cli, initialise tauri and manually\nconfigure the `tauri.conf.json` file. Once everything is installed, you can run:\n``` yarn tauri dev -or- npm run tauri dev ``` This will do several things: 1.\nstart the JS Framework devserver 2. begin the long process of downloading and\ncompiling the rust libraries 3. open an application window with devtools enabled\n4. keep a long-lived console alive If you change your HTML/CSS/TS/JS, your\nframework devserver should give you its best shot at instant hot module\nreloading and you will see the changes instantly. If you modify your rust code\nor anything in the Cargo.toml, the window will close while rust recompiles. When\nfinished it will reload. If you need to get deeper insight into your current\nproject, or triage requires investigation of installed components, just run: ```\nyarn tauri info ``` ## What does the Release flow look like? The release flow\nbegins with proper configuration in the `tauri.conf.json` file. In this file,\nthe developer can configure not only the basic behaviour of the application\n(like window size and decoration), they can also provide settings for signing\nand updating. Depending upon the operating system that the developer (or CI) is\nbuilding the application on, there will be an app built for them for that\nsystem. (Cross compilation is not currently available, however there is an\nofficial [GitHub Action](https://github.com/tauri-apps/tauri-action) that can be\nused to build for all platforms.) To kick off this process, just: ``` yarn tauri\nbuild ``` After some time, the process will end and you can see the results in\nthe `./src-tauri/target/release` folder. ## What does the End-User flow look\nlike? End users will be provided with binaries in ways that are appropriate for\ntheir systems. Whether macOS, Linux, or Windows, direct download or store\ninstallations - they will be able to follow procedures for installing and\nremoving that they are used to. ## What does the Updating flow look like? When a\nnew version is ready, the developer publishes the new signed artifacts to a\nserver (that they have configured within `tauri.conf.json`). The application can\npoll this server to see if there is a new release. When there is a new release,\nthe user is prompted to update. The application update is downloaded, verified\n(checksum & signature), updated, closed, and restarted. ## License Tauri itself\nis licensed under MIT or Apache-2.0. If you repackage it and modify any source\ncode, it is your responsibility to verify that you are complying with all\nupstream licenses. Tauri is provided AS-IS with no explicit claim for\nsuitability for any purpose. Here you may peruse our [Software Bill of\nMaterials](https://app.fossa.com/projects/git%2Bgithub.com%2Ftauri-apps%2Ftauri).","url":"https://tauri.studio/docs/about/architecture"},{"id":"prose_docs_about_book_md","title":"Get the book","area":"about","section":"about","headings":["Outline","Errata"],"subHeadings":["tl","Introduction","About the Topic","What you will learn","Stuff you","Chapter 1 ","Chapter 2 ","Chapter 3 ","Chapter 4 ","Chapter 5 "],"code":[null],"text":"import useBaseUrl from '@docusaurus/useBaseUrl' # Get the book\nTauri - From Theory to Practice [{useBaseUrl('img/bookCover.png')}]\n:::info Tauri: From Theory to Practice\nArchitecting Next-Gen Native-Apps for all Platforms [v1:Rust Edition]\nAuthors: [Daniel Thompson-Yvetot, Lucas Fernandes Gonçalves Nogueira]\nPublisher: TBD\nRelease: late 2020 ::: ### tl;dr; Visit https://opencollective.com/tauri and\npreorder your copy of the book today. Your donation will support the ongoing\ndevelopment of Tauri, and you will receive advance digital PDF's for your review\nas chapters are completed. The final book will ship concurrently with the\nrelease of 1.0.0 stable. If you donate 10 USD / month to Tauri, you will get the\nadvance PDF versions as soon as they are released. If you just want to donate\nonce: 15 USD for PDF and e-book, 30 USD for print version and PDF, 40 USD for\nall three. All tutorial subscription tiers receive the rolling PDF free of\nadditional charge. ### Introduction In 2020, the manufacture of native-apps has\nbecome easier and more accessible than ever before. All the same, beginners and\nseasoned developers alike are confronted with tough choices in a rapidly\nchanging landscape of security and privacy. This is especially true in the\nsemi-trusted environment of user devices. Tauri takes the guesswork out of the\nequation, as it was designed from the ground up to embrace new paradigms of\nsecure development and creative flexibility that leverage the language features\nof Rust and lets you build an app using any frontend framework you like. Find\nout how you can design, build, audit and deploy tiny, fast, robust, and secure\nnative applications for the major Desktop and Mobile platforms, all from the\nexact same codebase and in record time - without even needing to know the Rust\nprogramming language. Authors Daniel and Lucas, the architects behind Tauri take\nyou on a journey from theory to execution, during which you will learn why Tauri\nwas built and how it works under the hood. Together with guest personalities\nthat specialize in Open Source, DevOps, Security and Enterprise Architecture,\nthis book also presents discourse-formatted philosophical discussions and\nopen-source sustainability viewpoints from which your next-gen apps will profit\n- and your users will benefit. In this book you will follow the authors in the\niterative evolution of a real project from conception to distribution - all with\ncommentary, complete code resources, built, and packaged Native Apps for\nreference and staged Capture the Flag (CTF) challenges that progress in\ndifficulty as your comprehension of the system grows. ### About the Topic Tauri\nis a brand new way to make cross-platform native-apps for web, desktop and\nmobile. At this very moment, the pre-alpha version of this MIT licensed\ncommunity-based software is being prepared for public release:\nhttps://github.com/tauri-apps/tauri Tauri introduces novel methods for WebView\nintegration and innovative patterns for robust threat evasion. The 1.0 release\nwill ship with a multipurpose white-box analyzer and decompiler for any kind of\nbinary and an integrated CLI for ingesting any type of HTML; which, when\ncombined, provides developers and security teams with a holistic platform that\nhas never existed as a single unit before. Tauri bridges communities and opens\nup new opportunities for everyone from the front end developer all the way to\nthe low-level security and network administrators. Due to this level of\ncomplexity and robustness, it is important to publish a reference guide that\nwill necessarily be updated as major versions are released. ### What you will\nlearn By the end of this book you will understand: - The method and reasoning\nbehind the design of Tauri - The options you have when building with Tauri -\nThat having a moral compass is possible in software development - Why the Rust\nlanguage makes the most sense as a binding and application layer - Why Electron,\nCordova, React Native, Capacitor and others are no longer the best choice - Why\na binary review is important And you will be able to: - Transform a simple\nwebsite project into a Tauri Native-App - Make a variety of Tauri Application\nTypes based on the main Patterns - Decompile and analyze your App for Security\nIssues - Publish your App to a variety of App Stores - Read and write Rust code\n### Stuff you'll get if you preorder - Access to a real demo App built for all\nplatforms available at respective stores (that includes CTF Flags). - Exclusive\nOne-Pager cheat sheets made available for each section of the book, including\nthe Appendices. - Early access to videos / webcasts. - Discounted participation\nin the “Capture the Flag” event hosted at the launch of the book. ## Outline\nThis is an early outline of the contents that we expect to publish. Contents\nsubject to change. ### Chapter 1 - Theory (ca. 50 pages - mostly conversational\n/ technical, graphics) ``` 1. Security Starts with You 2. Privacy Ends with\n${you} 3. Languages, Dialects and Patterns 4. Toolchains and Syntactic Sugar 5.\nProduction Methodologies 6. Enterprise Readiness 7. Message Queueing 8.\nEmbracing Chaos 9. Distribution Techniques 10. Licensing Strategies ``` ###\nChapter 2 - Practice (ca. 130 pages w/ charts, screenshots, code samples) ``` 1.\nEnvironment Prerequisites - Node, Npm, Yarn, Rustc, Rustup, Buildtools 2.\nDevelopment Platform Details - macOS - Windows - Linux - Docker - Virtual\nMachines - CI / CD 3. Tauri Introduction 4. Tauri Anatomy 5. Tauri Configuration\n- Files & Folders - Icons - Splash Screens - Window -\n`src-tauri/tauri.conf.json` 6. Preparing your code - Transpile dynamic imports -\nRemove webpack chunking - Monolithic Files - Minification strategies 7. Tauri\nAPI - Design Considerations - API Usage Patterns - Custom API Functions -\nEndpoints - All - Answer - Bridge - Event - Execute - List Files - Open - Read\nBinary File - Read Text File - Set Title - Window - Write File 8. Web APIs 9.\nTauri App Extensions - Anatomy - Flow - Registration - Publication - API 10.\nTaskbar Integration (Desktop Only) - Anatomy - Integrations - macOS - Windows -\nLinux 11. Security Features - Baseline Rust Features - Functional Address Space\nLayout Randomization (fASLR) - Ahead of Time (AoT) Compilation - Content\nSecurity Policy (CSP) - One Time Pads (OTP) - Embedded Server: False - API\nTree-Shaking - Matryoschkasumming (with Tauri-Frida) 12. Bridges and Brokers -\nBridge Patterns - Message hashing with OTP - Plugin Pattern - Kamikaze Function\nInjection (KFI) Closures 13. Testing - Unit Testing - Rust - JS - Integration\nTesting - e2e Testing 14. Building - Debugging - Packaging - Minification -\nDistribution Platform Details - macOS (.app / .dmg) - Win (.exe / .msi) - Linux\nArm64 (.appImage / .deb) - Linux x64 (.appImage / .deb) - iOS (.ipa) - Android\n(.apk) - PWA Website (with wasm) - Code Signing - Keystores - Certs -\nFingerprints - Providing License for End Users - Providers - Keys Files -\nSelf-Updater - Anatomy - Service Provisioning - Github - AWS - Homegrown -\nCross-Platform Bundler 15. Tauri-Frida Harness - Introduction to Reverse\nEngineering - Toolchain - Usage - Binary Hooking at Runtime - Pointer Evaluation\n- Spraying, Fuzzing, Spoofing - Report Generation - Recompilation - Post-Binary\nAnalysis 16. Distribution - Git - Mac Store - iOS Store - Play store - Windows\nStore - Snap Store - PureOS Store - .deb channels - .tar.gz - homebrew - Fdroid\n- Cydia - ChromeOS - WASM ``` ### Chapter 3 - Philosophical Discourses (ca. 40\npages of essays, some graphics) ``` 1. Rights and Responsibilities (with Robin\nvan Boven (SFOSC)) - Who You are Responsible To - Being a Vendor Comes with\nDuties - Ubiquitous Resources are Still Precious - Use Policy to Address\nResponsibilities - Take a Hippocratic Development Oath 2. Take a More Secure\nStance (with Liran Tal (SNYK)) - Security Benefits of Frameworks - Encrypt All\nthe Things, All the Time - Constantly Audit Project Dependencies - Harden\nYourself, Your Organization and Your Ecosystem - “Do What You Can Until You Run\nOut of Time.” - [ROBERT C. SEACORD] 3. Production Strategies for Sustainability\n(with Rhys Parry (Independent)) - Develop in the “Perfect” Environment - Minimal\nImpact for Existing Enterprise Architectures - Use Low-Barrier Tools for\nEnsuring Wholestack Security - Test the Right Things Intelligently - Post-Binary\nAnalysis and Redistribution - The Last Mile ``` ### Chapter 4 - Execution (ca.\n100 pages w/ code examples, screenshots, graphics) ``` 1. Base Pattern Evolution\n- Hermit - Bridge - Cloudish - Cloudbridge - Lockdown - Multiwin - GLUI 2.\nAdvanced Patterns - Cryptographic Enclave - Identity Management - Combine an App\nwith a Daemon - IPC / RPC - Integrate with DENO 3. UI Source Complilation -\nReact - Vue - Angular - Svelte - Gatsby 4. Building a Real App - Multiparty\nPassword Manager - Design - Prototyping - Testing - Debugging - Packaging -\nChecksumming 5. Tauri-Frida - White Box Reversing - Analyzing with Frida - Chaos\nExperiments - Interface Jacking - Disk Change - Latency - Process Kill - CPU\nThrottle - Static Analysis Reporting - Binary Repackaging - Inject License Keys\n- Clear Dead Codepoints - Recalculate Integrated Checksum 6. Publishing the App\n- Git - Mac Store - iOS Store - Play store - Windows Store - Snap Store - PureOS\nStore - .deb channels - .tar.gz - homebrew - Fdroid - Cydia - ChromeOS - WASM 7.\nPublishing an Update ``` ### Chapter 5 - Appendices (ca. 120 pages) ``` 1.\nConfiguration Options 2. Files and Repositories 3. Tauri CLI references 4. Tauri\nAPI references 5. ES6 References 6. Rust References 7. App Pattern Charts 8.\nTauri-Frida Reference 9. Glossary 10. Index ``` ## Errata Got something that you\nthink should be in the book? Want to be our publisher? Reach out to us and let\nus know!","url":"https://tauri.studio/docs/about/book"},{"id":"prose_docs_about_governance_md","title":"Governance","area":"about","section":"about","headings":["Sustainability"],"subHeadings":["Organizational Structure","Code of Conduct","Social Contract","Licensing","Trademark"],"code":[],"text":"# Governance ## Sustainability One of the main goals of the organizational\nstructure of Tauri is to guarantee the sustainability of Tauri and the health\nand well-being of its contributors. The world of Open Source is fraught with\nperil and discord, and we have taken measures to ensure the longevity of Tauri.\nThis document explains how we go about doing so. ### Organizational Structure\nTauri apps is governed by the community and work is done in the context of\npublic working groups. Each working group has a dedicated channel on the Discord\nserver as well as a Team on GitHub. Other than that, each WG is free to use\nwhatever type of organizational model it chooses. The current working groups\nare: - WG Governance & Guidance - WG Tech - WG Education - WG Media - WG\nSecurity - WG Devops With the exception of the security working group, which is\nby invite only and convenes privately, all other working groups are public and\nopen to any and all participants. Please visit [this\nrepository](https://github.com/tauri-apps/governance-and-guidance) to get more\ninformation. ### Code of Conduct Everyone participating in the Tauri community\nis expected to follow a code of conduct that you can at the [Governance and\nGuidance:Code of\nConduct](https://github.com/tauri-apps/governance-and-guidance/blob/master/CODE_OF_CONDUCT.md).\n### Social Contract We have a Social Contract that informs our decision making\nand organization. You can read about it here: [Governance and Guidance:Social\nContract](https://github.com/tauri-apps/governance-and-guidance/blob/master/SOCIAL_CONTRACT.md).\n### Licensing We, the contributors to Tauri Apps, use the MIT and Apache\nlicenses for all code content. Images and bodies of text, unless otherwise noted\nare CC-BY-ND-NC. ### Trademark It is a permissible use of the name \"Tauri App\"\nor the Tauri logo to show that a project uses Tauri. \"Tauri Studio\" is reserved\nfor use by the organization. Any language that gives the impression that the\nTauri organization approves, authorizes or otherwise supports a project, person\nor company is not permissible without written authorization from the Guidance\nand Governance Working Group.","url":"https://tauri.studio/docs/about/governance"},{"id":"prose_docs_about_intro_md","title":"What is Tauri","area":"about","section":"about","headings":["Security First","Polyglots","Honest Open Source","The Future"],"subHeadings":[],"code":[],"text":"# What is Tauri? Tauri is a toolkit that helps developers make applications for\nthe major desktop platforms - using virtually any frontend framework in\nexistence. The core is built with Rust, and the CLI leverages Node.js making\nTauri a genuinely polyglot approach to creating and maintaining great apps. If\nyou want to know more about the technical details, then please visit the\n[Introduction](/docs/getting-started/beginning-tutorial). If you want to know\nmore about this project's philosophy - then keep reading.\n\n## Security First In today's world, every honest threat model assumes that the\nuser's device has already been compromised. This puts app developers in a\ncomplicated situation because if the device is already at risk, how can the\nsoftware be trusted? Defense in depth is the approach we've taken. We want you\nto be able to take every precaution possible to minimize the surface area you\npresent to attackers. Tauri lets you choose which API endpoints to ship, whether\nor not you want a localhost server built into your app, and it even randomizes\nfunctional handles at runtime. These and other techniques form a secure baseline\nthat empowers you and your users. Slowing down attackers by making static\nattacks crushingly difficult and isolating systems from one another is the name\nof the game. And if you are coming from the Electron ecosystem - rest assured -\nby default Tauri only ships binaries, not ASAR files. By choosing to build Tauri\nwith security as a guiding force, we give you every opportunity to take a\nproactive security posture. ## Polyglots, not Silos Most contemporary frameworks\nuse a single language paradigm and are therefore trapped in a bubble of\nknowledge and idiom. This can work well for certain niche applications, but it\nalso fosters a kind of tribalism. This can be seen in the way that the React,\nAngular, and Vue development communities huddle on their stacks, ultimately\nbreeding very little cross-pollination. This same situation can be seen in the\nRust vs. Node vs. C++ battlefields, where hardliners take their stances and\nrefuse to collaborate across communities. Today, Tauri uses Rust for the backend\n- but in the not too distant future, other backends like Go, Nim, Python,\nCsharp, etc. will be possible. This is because we are maintaining the official\nRust bindings to the [webview](https://github.com/webview) organization and plan\nto let you switch out the backend for your needs. Since our API can be\nimplemented in any language with C interop, full compliance is only a PR away.\n## Honest Open Source None of this would make any sense without a community.\nToday software communities are amazing places where people help each other and\nmake awesome things - open source is a very big part of that. Open source means\ndifferent things to different people, but most will agree that it serves to\nsupport freedom. When software doesn't respect your rights, then it can seem\nunfair and potentially compromise your freedoms by operating in unethical ways.\nThis is why we are proud that FLOSS advocates can build applications with Tauri\nthat are \"certifiably\" open source and can be included in FSF endorsed GNU/Linux\ndistributions. ## The Future Tauri's future depends on your involvement and\ncontributions. Try it out, file issues, join a working group or make a donation\n- every contribution is important. Please, at any rate, do get in touch!!!","url":"https://tauri.studio/docs/about/intro"},{"id":"prose_docs_about_security_md","title":"Security","area":"about","section":"about","headings":["No Server Required","Language Features of Rust","Dynamic Ahead of Time Compilation ","Function Hardening","System Features","Ecosystem","Future Work"],"subHeadings":["Security Researchers","Functional ASLR","Kamikaze Function Injection","Bridge","One Time Pad Tokenization and Hashing","Allowing API","Content Security Policy Management","Decompilation is Difficult","Build Pipelines and Artifact Authenticity","Resilient PR and Approval Processes","Signed Binaries","Post","Post","Audits"],"code":[],"text":"# Security This guide seeks to explain the high-level concepts and Security\nFeatures at the core of Tauri's design that makes you, your apps, and your users\nsafer by default. ::: Please note:\nWhile we take every opportunity to help you harden your application - there are\nalways underlying threats like BIOS attacks, memory rowhammering and other\noperating system vulnerabilities that are constantly being discovered and (in\nthe best cases) responsibly disclosed.\nFurthermore, there are many ways that development teams can cut corners and\neither leak sensitive information or leave doors wide open to any of a range of\nattacks. Security is a never-ending quest, and your users count on you to keep\nthem safe.\nTherefore, we highly recommend that you take some time to consider the security\nramifications of everything that your application does, especially in the\ncontext of running on the semi-hostile platform of end-user devices.\nIf you need help or want a review, you are welcome to contact the Tauri team for\nsecurity consultation. ::: ### Security Researchers If you feel that there is a\nsecurity concern or issue with anything in Tauri, please do not publicly comment\non your findings. Instead, reach out directly to our security team: >\nsecurity@tauri.studio Although we do not currently have a budget for Security\nBounties, in some cases, we will consider rewarding responsible disclosure with\nour limited resources. ## No Server Required Tauri enables you to construct an\napplication that uses web technology for the user interface without requiring\nyou to use a server to communicate with the backend. Even if you used advanced\ntechniques of dynamic imports and offload work to the backend, no traffic can be\nsniffed on TCP ports or external processes - because they aren't there. This\nreduces not only the physical and virtual footprint of your final binary by a\ngood deal, but it also reduces the surface area of potential attack vectors by\nremoving them from the equation. ## Language Features of Rust By turning to the\nprogramming language renowned for its memory safety and speed, Tauri simply\nerases whole classes of conventional attacks. `Use after free` just isn't\nsomething that can happen with Tauri. ## Dynamic Ahead of Time Compilation (AOT)\nThis compilation process happens several times during the bootstrapping phase of\na Tauri app. Using our default dynamic Ahead of Time compiler, you can generate\ncode references that are unique for every session and are still technically\nstatic code units. ## Function Hardening ### Functional ASLR Functional address\nSpace Layout Randomization techniques randomize function names at runtime and\ncan implement OTP hashing, so no two sessions are ever the same. We propose a\nnovel type of function naming at boot time and optionally after every execution.\nUsing a UID for each function pointer prevents static attacks. ### Kamikaze\nFunction Injection This advanced type of fASLR using the `EVENT` API endpoint is\na promise wrapped in a closure (with randomized handle) that Rust inserts at\nruntime into the WebView, where its interface is locked within the promise\nresolution handler and is nulled after execution. ### Bridge, don't serve\nInstead of passing potentially unsafe functions, an event bridge can be used to\npass messages and commands to named brokers at each respective side of the\napplication. ### One Time Pad Tokenization and Hashing Hashing important\nmessages with an OTP salt, you are able to encrypt messages between the user\ninterface and the Rust backend. We are currently investigating the use of\nadditional sources of entropy, such as the amazing [Infinite Noise\nTRNG](https://13-37.org/en/shop/infinite-noise-trng/). ## System Features ###\nAllowing API You have the ability to pick and choose which API functions are\navailable to the UI and to Rust. If they are not enabled, the code will not be\nshipped with your app, which reduces binary size and attack surface. They are\nopt-in, so you have to consciously choose to progressively enhance your\napplication. ### Content Security Policy Management Preventing unauthorized code\nexecution for websites has long since been \"resolved\" by using CSPs. Tauri can\ninject CSPs into the index.html of the user interface, and when using a\nlocalhost server, it will also send these headers to the UI or any other clients\nthat connect with it. ### Decompilation is Difficult This means that your apps\ncannot be easily decompiled, as is the case with Electron ASAR files, which\nmakes the process of reverse engineering your project much more time-intensive\nand requires specialist training. ## Ecosystem ### Build Pipelines and Artifact\nAuthenticity The process of releasing our source-code artifacts is highly\nautomated yet mandates kickoff and review from real humans. Our current release\nstrategy uses a combination of Github Actions and IOTA Tangle publication ###\nResilient PR and Approval Processes Our WG-TECH reviews code changes, tags PRs\nwith scope, and makes sure that everything stays up to date. And when its time\nto publish a new version, one of the maintainers tags a new release on master,\nwhich: - validates core - runs smoke tests - audits security for crates and npm\n- generates changelogs - creates artifacts - publishes checksums to IOTA -\ncreates a draft release Then the maintainer reviews the release notes, edits if\nnecessary - and a new release is forged. ## Future Work ### Signed Binaries\nBecause the entire project is shipped within a monolithic binary, code can be\nsigned for all distributables. (Currently using external tooling, but we are\nactively working on making the bundler a one-stop-shop.) This makes it virtually\nimpossible for hackers to change an installed Application without the operating\nsystem noticing. [Reference](https://github.com/electron/asar/issues/123) ###\nPost-Binary Analysis Use industrial-grade pentester-tooling (via our forthcoming\nTauri-Frida GUI) to discover and fix security weaknesses in your final binaries.\n### Post-Binary Enhancement After the build is before the delivery and Tauri\nwill provide you with tools never seen before. Stay tuned! ### Audits We are\ncurrently in the process of our first external audit. When complete, we will\npublish the results here.","url":"https://tauri.studio/docs/about/security"},{"id":"prose_docs_architecture_build_tools_md","title":"Node Build Tools","area":"architecture","section":"architecture","headings":[],"subHeadings":[],"code":[],"text":"This is a stub. Could add notes about Vite, Webpack, Rollup, etc.","url":"https://tauri.studio/docs/architecture/build-tools"},{"id":"prose_docs_architecture_frontend_frameworks_md","title":"Frontend Frameworks","area":"architecture","section":"architecture","headings":[],"subHeadings":[],"code":[],"text":"This is a stub. Could add notes about Vite, Webpack, Rollup, etc.","url":"https://tauri.studio/docs/architecture/frontend-frameworks"},{"id":"prose_docs_architecture_patterns_brownfield_md","title":"Brownfield Pattern","area":"architecture","section":"patterns","headings":["Incompatibilities","Configuration"],"subHeadings":[],"code":["json"],"text":"# Brownfield Pattern _**This is the default pattern.**_ This is the simplest and\nmost straightforward pattern to use Tauri with due to it trying to be the most\ncompatible with existing frontend projects as much as it can. In short, it tries\nto require nothing additional to what an existing web frontend might use inside\na browser. Not _**everything**_ that works in existing browser applications will\nwork out-of the box, see the [Incompatibility section](#incompatibilities) for\nmore details. If you are unfamiliar with Brownfield software development in\ngeneral, the [Brownfield Wikipedia\narticle](https://en.wikipedia.org/wiki/Brownfield_(software_development))\nprovides a nice summary of it. For Tauri, the existing software is current\nbrowser support and behavior instead of legacy systems. ## Incompatibilities The\nfirst incompatibility category is easy, any browser-specific APIs will not work\nproperly inside Tauri (even while using the Brownfield pattern). If the API is\nnot widely supported across browsers, it's likely not going to be supported\nacross all platforms while using Tauri. The second incompatibility category is\nfeatures that are planned for Tauri but are currently not fully implemented.\nHere is a list of examples: * [WebRTC support on\nLinux](https://github.com/tauri-apps/wry/issues/85) * [Some permissions\nAPIs](https://github.com/tauri-apps/wry/issues/81) * [Download Links/Blob as\nURL](https://github.com/tauri-apps/wry/issues/349) * [Better\ni18n](https://github.com/tauri-apps/wry/issues/442) ## Configuration Because the\nBrownfield pattern is the default pattern, no configuration option is required\nto be set. To explicitly set it, you can use the `tauri > pattern` object in the\n`tauri.conf.json` configuration file. ```json { \"tauri\": { \"pattern\": { \"use\":\n\"brownfield\" } } } ``` _**There are no additional configuration options for the\nbrownfield pattern.**_","url":"https://tauri.studio/docs/architecture/patterns/brownfield"},{"id":"prose_docs_architecture_patterns_isolation_md","title":"Isolation Pattern","area":"architecture","section":"patterns","headings":["Why","When","How","Recommendations","Creating the Isolation Application","Configuration"],"subHeadings":["Approximate Steps of an IPC Message","Performance Implications","Limitations"],"code":["html","js","json"],"text":"","url":"https://tauri.studio/docs/architecture/patterns/isolation"},{"id":"prose_docs_architecture_recipes_about_recipes_md","title":"A word on recipes","area":"architecture","section":"recipes","headings":[],"subHeadings":[],"code":[],"text":"Tauri recipes are descriptions of use-cases that are entirely configurable\nwithin the `src-tauri/tauri.conf.json` file. These are not the limits of what\nTauri can do, and there are probably more out there. If you discover one, why\nnot get in touch and help us update this collection! If you haven't read about\nthe general design of Tauri, then it would make the most sense for you to visit\nthe [\"Getting Started\"](/docs/getting-started/beginning-tutorial) and become\nfamiliar with the basic architecture and terminology used in these recipes.","url":"https://tauri.studio/docs/architecture/recipes/about-recipes"},{"id":"prose_docs_architecture_recipes_bridge_md","title":"Bridge","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nBridge [{useBaseUrl('img/recipes/Bridge.svg')}]\nPros:\n * Highly configurable\n * No Rust skills required\n\nCons:\n * Some WebAPIs unavailable\n * Challenge to implement\n\n## Description The Bridge recipe is a secure pattern where messages are passed\nbetween brokers via an implicit bridge using the API. It isolates functionality\nto scope and passes messages instead of functionality. ## Diagram import\nMermaid, { colors } from '@theme/Mermaid' F subgraph WEBVIEW F-.-E end D-->E\nE-->D B-->D D-->B subgraph RUST A==>H A-->B B-.-C B-.-G end A[Binary] B{Rust\nBroker} C[Subprocess 2] G[Subprocess 1] D(( API BRIDGE )) E{JS Broker} F[Window]\nH{Bootstrap} style D fill:#ccc,stroke:#333,stroke-width:4px,color:white style\nRUST fill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px\nstyle WEBVIEW\nfill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`} /> ##\nConfiguration Here's what you need to add to your tauri.conf.json file: ```json\n{ \"tauri\": { \"allowlist\": { \"all\": false, \"clipboard\": { \"all\": false,\n\"readText\": false, \"writeText\": false }, \"dialog\": { \"all\": false, \"ask\": false,\n\"confirm\": false, \"message\": false, \"open\": false, \"save\": false }, \"fs\": {\n\"all\": false, \"copyFile\": false, \"createDir\": false, \"readDir\": false,\n\"readFile\": false, \"removeDir\": false, \"removeFile\": false, \"renameFile\": false,\n\"scope\": [], \"writeFile\": false }, \"globalShortcut\": { \"all\": false }, \"http\": {\n\"all\": false, \"request\": false, \"scope\": [] }, \"notification\": { \"all\": false },\n\"os\": { \"all\": false }, \"path\": { \"all\": false }, \"process\": { \"all\": false,\n\"exit\": false, \"relaunch\": false, \"relaunchDangerousAllowSymlinkMacos\": false },\n\"protocol\": { \"all\": false, \"asset\": false, \"assetScope\": [] }, \"shell\": {\n\"all\": false, \"execute\": false, \"open\": false, \"scope\": [], \"sidecar\": false },\n\"window\": { \"all\": false, \"center\": false, \"close\": false, \"create\": false,\n\"hide\": false, \"maximize\": false, \"minimize\": false, \"print\": false,\n\"requestUserAttention\": false, \"setAlwaysOnTop\": false, \"setDecorations\": false,\n\"setFocus\": false, \"setFullscreen\": false, \"setIcon\": false, \"setMaxSize\":\nfalse, \"setMinSize\": false, \"setPosition\": false, \"setResizable\": false,\n\"setSize\": false, \"setSkipTaskbar\": false, \"setTitle\": false, \"show\": false,\n\"startDragging\": false, \"unmaximize\": false, \"unminimize\": false } } } } ```","url":"https://tauri.studio/docs/architecture/recipes/bridge"},{"id":"prose_docs_architecture_recipes_cloudbridge_md","title":"Cloudbridge","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudbridge [{useBaseUrl('img/recipes/Cloudbridge.svg')}]\nPros:\n * All available features\n * No Rust skills required\n\nCons:\n * Largest bundle size\n * Hard to separate concerns\n\n## Description The Cloudbridge recipe combines the flexibility of a localhost\nand the security of the bridge. With so many features, it can be easy to get\nlost. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' F2 H==>D2\nD2-->F2 F2-->D2 B-->D D-->B E2-->D D-->E2 subgraph WEBVIEW F2 E2 end subgraph\nSERVER D2 E-->D2 end subgraph RUST A==>H A-->B B-.-C end A[Binary] B{Rust\nBroker} C[Subprocess] D(( API BRIDGE )) E{JS Broker} D2(( localhost )) E[bundled\nresources] E2{JS Broker} F2[Window] H{Bootstrap} style D\nfill:#ccc,stroke:#333,stroke-width:4px,color:white style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px `} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": true // enable entire API } } ```","url":"https://tauri.studio/docs/architecture/recipes/cloudbridge"},{"id":"prose_docs_architecture_recipes_cloudish_md","title":"Cloudish","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nCloudish [{useBaseUrl('img/recipes/Cloudish.svg')}]\nPros:\n * Similar to a SPA web-app\n * No Rust skills required\n\nCons:\n * No access to Rust API\n * Uses a localhost server\n\n## Description The Cloudish recipe is a pattern for maximum flexibility and app\nperformance. It uses a localhost server, which means that your app will\ntechnically be available to other processes, like browsers and potentially other\ndevices on the network. All of your assets are baked into the binary, but served\nas if they were distinct files. ## Diagram import Mermaid, { colors } from\n'@theme/Mermaid' F H==>D D-->F F-->D subgraph RUST A==>H end subgraph WEBVIEW F\nend subgraph SERVER D E-->D end A[Binary] D(( localhost )) E[bundled resources]\nF[Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px\nstyle SERVER fill:#49A24A,stroke:#2B6063,stroke-width:4px`} /> ## Configuration\nHere's what you need to add to your tauri.conf.json file: ```json \"tauri\": {\n\"allowlist\": { \"all\": false // disable entire API } } ```","url":"https://tauri.studio/docs/architecture/recipes/cloudish"},{"id":"prose_docs_architecture_recipes_glui_md","title":"GLUI","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nThis pattern is not available for now. import Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nGLUI [{useBaseUrl('img/recipes/GLUI.svg')}]\nPros:\n * Framebuffer FTW\n * Window events rigged\n\nCons:\n * Broken on your machine\n\n## Description The GLUI is a research pattern that we will use internally to\ntest approaches using a GLUTIN window. We’re not sure yet if it will make the\nfinal cut as a bona fide alternative to WebView, although early tests with\ntransparent and multiwindow are exciting. ## Diagram import Mermaid, { colors }\nfrom '@theme/Mermaid' H H==>G A-->D D-->G subgraph GLUTIN G end subgraph RUST A\nend A[Binary] D(Framebuffer) G[GL Window] H{Bootstrap} style GLUTIN\nstroke:${colors.blue.dark},stroke-width:4px style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px`} />\n## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { // all API endpoints are default false \"all\":\nfalse, // disable the api }, \"window\": { // not yet normative \"glutin\": true,\n\"webview\": false } } ```","url":"https://tauri.studio/docs/architecture/recipes/glui"},{"id":"prose_docs_architecture_recipes_hermit_md","title":"Hermit","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":["json"],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nHermit [{useBaseUrl('img/recipes/Hermit.svg')}]\nPros:\n * Quick to make\n * Smallest size\n\nCons:\n * No remote resources\n * No access to API\n\n## Description The Hermit recipe is a pattern for ultimate application isolation\nwhere all logic is self-contained in the Window and the binary exists merely to\nbootstrap the Window. There is no communication back to Rust from the Window,\nthere is no localhost server, and the Window has no access to any remote\nresources. The Hermit is great for interactive Kiosk Mode and standalone HTML\nbased games. ## Diagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F\nsubgraph WEBVIEW F end subgraph RUST A end A[fa:fa-cog Binary ]\nF[fa:fa-window-maximize Window] H{Bootstrap} style RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": { \"all\": false, // disable and tree-shake all\napi functions } } ```","url":"https://tauri.studio/docs/architecture/recipes/hermit"},{"id":"prose_docs_architecture_recipes_lockdown_md","title":"Lockdown","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":["json"],"text":"import Rater from '@theme/Rater' import useBaseUrl from '@docusaurus/useBaseUrl'\n\nEase of Use Extensibility Performance Security\n\nLockdown [{useBaseUrl('img/recipes/Lockdown.svg')}]\nPros:\n * Highest security rating\n * Elegant and powerful\n\nCons:\n * Rust skills required\n * No remote resources\n\n## Description The Lockdown recipe is a minimal usage of the [Bridge\npattern](./bridge.md), which only allows interaction between Rust and the Window\nvia expiring JS Promise Closures that are injected into the Window by Rust and\nnulled as part of the callback. ## Diagram import Mermaid, { colors } from\n'@theme/Mermaid' F G-.->B B-->G subgraph WEBVIEW G-->F end subgraph RUST A-->B\nA==>H end A[Binary] B[API:Event] F[Window] G((Promise Closure)) H{Bootstrap}\nstyle RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {} // all API endpoints are default false } ```","url":"https://tauri.studio/docs/architecture/recipes/lockdown"},{"id":"prose_docs_architecture_recipes_multiwin_md","title":"Multiwin","area":"architecture","section":"recipes","headings":["Description","Diagram","Configuration"],"subHeadings":[],"code":[],"text":"import Alert from '@theme/Alert' import useBaseUrl from '@docusaurus/useBaseUrl'\nimport Rater from '@theme/Rater'\n\nEase of Use Extensibility Performance Security\n\nMultiwin [{useBaseUrl('img/recipes/Multiwin.svg')}]\nPros:\n * Windows can be spawned or destroyed at runtime\n * Separation of concerns\n\nCons:\n * Somewhat complex\n\n## Description The Multiwin recipe will allow you to have multiple windows. ##\nDiagram import Mermaid, { colors } from '@theme/Mermaid' H H==>F H==>G subgraph\nWEBVIEW F end subgraph WINIT G end subgraph RUST A end A[Binary] F[Window]\nG[Window] H{Bootstrap} style WINIT stroke:${colors.blue.dark},stroke-width:4px\nstyle RUST\nfill:${colors.orange.light},stroke:${colors.orange.dark},stroke-width:4px style\nWEBVIEW fill:${colors.blue.light},stroke:${colors.blue.dark},stroke-width:4px`}\n/> ## Configuration Here's what you need to add to your tauri.conf.json file:\n```json \"tauri\": { \"allowlist\": {}, // all API endpoints are default false\n\"windows\": [{ \"title\": \"Window1\", \"label\": \"main\", }, { \"title\": \"Splash\",\n\"label\": \"splashscreen\" }] } ```","url":"https://tauri.studio/docs/architecture/recipes/multiwin"},{"id":"prose_docs_building_app_size_md","title":"Reducing the App Size","area":"building","section":"building","headings":["Checklist","1","2","3","4","5","6","7","8"],"subHeadings":["You can","Think twice before adding a dependency","Why","How","Why","How","Why","How","Why","How","Why","How","Why","How","Unstable Rust Compression Features","Why","How","Why","How"],"code":["css","json","toml","sh"],"text":"# Reducing the App Size At Tauri, we are working on reducing the environmental\nfootprint of applications by using system resources where available, providing\ncompiled systems that don't need runtime evaluation, and offering guides so that\nengineers can go even smaller without sacrificing on performance or security.\nThe point is, by saving resources, we are doing our part to help you help us\nsave the planet -- which is the only bottom line that companies in the 21st\nCentury should care about. So if you are interested in learning how to improve\nyour app size and performance, read on, dear friend: ### You can't improve what\nyou can't measure Before you can optimize your app, you need to figure out what\ntakes up space in your app! Here are a couple of tools that can assist you with\nthat: - **`cargo-bloat`** [`cargo-bloat`][cargo-bloat] is a rust utility to\ndetermine what takes the most space in your app. It gives you an excellent,\nsorted overview of the most significant rust functions. - **`cargo-expand`**\n[Macros] make your rust code more concise and easier to read, but they are also\nhidden size traps! Use [`cargo-expand`][cargo-expand] to see what those macros\ngenerate under the hood. - **`rollup-plugin-visualizer`**\n[`rollup-plugin-visualizer`][rollup-plugin-visualizer] generates beautiful (and\ninsightful) graphs from your rollup bundle. Very convenient for figuring out\nwhat JavaScript dependencies contribute to your final bundle size the most. -\n**`rollup-plugin-graph`** You noticed a dependency included in your final\nfrontend bundle, but you are unsure why?\n[`rollup-plugin-graph`][rollup-plugin-graph] generates graphviz compatible\nvisualizations of your entire dependency graph. These are just a couple of tools\nthat you might use. Make sure to check your frontend bundlers plugin list for\nmore! ### Think twice before adding a dependency ## Checklist - [Reducing the\nApp Size](#reducing-the-app-size) - [You can't improve what you can't\nmeasure](#you-cant-improve-what-you-cant-measure) - [Think twice before adding a\ndependency](#think-twice-before-adding-a-dependency) - [Checklist](#checklist) -\n[1. Minify Javascript](#1-minify-javascript) - [Why?](#why) - [How?](#how) - [2.\nOptimize Dependencies](#2-optimize-dependencies) - [Why?](#why-1) -\n[How?](#how-1) - [3. Optimize Images](#3-optimize-images) - [Why?](#why-2) -\n[How?](#how-2) - [4. Remove Unnecessary Custom\nFonts](#4-remove-unnecessary-custom-fonts) - [Why?](#why-3) - [How?](#how-3) -\n[5. Allowlist Config](#5-allowlist-config) - [Why?](#why-4) - [How?](#how-4) -\n[6. Rust Build-time Optimizations](#6-rust-build-time-optimizations) -\n[Why?](#why-5) - [How?](#how-5) - [Unstable Rust Compression\nFeatures](#unstable-rust-compression-features) - [7. Stripping](#7-stripping) -\n[Why?](#why-6) - [How?](#how-6) - [8. UPX](#8-upx) - [Why?](#why-7) -\n[How?](#how-7) - [Usage on macOS](#usage-on-macos) ## 1. Minify Javascript ###\nWhy? JavaScript makes up a large portion of a typical Tauri app, so it's\nimportant to make the JavaScript as lightweight as possible. ### How? You can\nchoose among a plethora of JavaScript bundlers; popular choices are [Vite],\n[webpack], and [rollup]. All of them can produce minified JavaScript if\nconfigured correctly, so please consult your bundler documentation for specific\noptions. Generally speaking; however, you should make sure to: - **Enable tree\nshaking** This option removes unused JavaScript from your bundle. All popular\nbundlers enable this by default. - **Enable minification** Minification removes\nunnecessary whitespace, shortens variable names, and applies other\noptimizations. Most bundlers enable this by default; a notable exception is\n[rollup], where you need plugins like [rollup-plugin-terser] or\n[rollup-plugin-uglify]. :::note You can use minifiers like [terser] and\n[esbuild] as standalone tools. ::: - **Disable source maps** Source maps provide\na pleasant developer experience when working with languages that compile to\nJavaScript, such as [TypeScript]. As source maps tend to be quite large, you\nmust disable them when building for production. They have no benefit to your\nend-user, so it's effectively dead weight. ## 2. Optimize Dependencies Many\npopular libraries have smaller and faster alternatives that you can choose\ninstead. ### Why? Most libraries you use depend on many libraries themselves, so\na library that looks inconspicuous at first glance might add **several\nmegabytes** worth of code to your app. ### How? You can use [Bundlephobia] to\nfind the cost of JavaScript dependencies. Inspecting the cost of rust\ndependencies is generally harder since the compiler does many optimizations. If\nyou find a library that seems excessively large, google around, chances are\nsomeone else already had the same thought and created an alternative. A good\nexample is [Moment.js] and it's [Many alternatives][you-dont-need-momentjs]. But\nkeep in mind: **The best dependency is no dependency**, meaning that you should\nalways prefer language builtins over 3rd party packages. ## 3. Optimize Images\n### Why? According to the [Http Archive], images are the [biggest contributor to\nwebsite weight][http archive report, image bytes]. So if your app includes have\nbackground images or icons, make sure to optimize them! ### How? You can choose\nbetween a variety of manual options ([GIMP], [Photoshop], [Squoosh]) or plugins\nfor your favorite frontend build tools ([vite-imagetools],\n[vite-plugin-imagemin], [image-minimizer-webpack-plugin]). :::caution The\n`imagemin` library most of the plugins use is [officially unmaintained][imagemin\nis unmaintained]. ::: - **Use modern image formats** Formats such as `webp` or\n`avif` offer size reductions of **up to 95%** compared to jpeg while maintaining\nexcellent visual accuracy. You can use tools such as [Squoosh] to try different\nformats on your images. - **Size images accordingly** No one appreciates you\nshipping the 6K raw image with your app, so make sure to size your image\naccordingly. Images that appear large on-screen should be sized larger than\nimages that take up less screen space. - **Don't use Responsive Images** In a\nWeb Environment, you are supposed to use [Responsive Images] to load the correct\nimage size for each user dynamically. You are not building a simple website,\nthough: All your images are already downloaded. So using Responsive Images only\nbloat your app with redundant copies. - **Remove Metadata** Images that were\ntaken straight from a camera or stock photo side often include metadata about\nthe Camera and Lens model or Photographer. Not only are those wasted bytes, but\nmetadata properties can also hold potentially sensitive information such as the\ntime, day, and location of the photo. ## 4. Remove Unnecessary Custom Fonts\nConsider not shipping custom fonts with your app and relying on system fonts\ninstead. If you must ship custom fonts, make sure they are in modern, optimized\nformats such as `woff2`. ### Why? Fonts can be pretty big, so using the fonts\nalready included in the Operating System reduces the footprint of your app. It\nalso avoids FOUT (Flash of Unstyled Text) and makes your app feel more \"native\"\nsince it uses the same font as all other apps. If you must include custom fonts,\nmake sure you include them in modern formats such as `woff2` as those tend to be\nway smaller than legacy formats. ### How? Use so-called **\"System Font Stacks\"**\nin your CSS. There are a number of variations, but here are 3 basic ones to get\nyou started: - **Sans-serif** ```css font-family: -apple-system,\nBlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif, 'Apple Color\nEmoji', 'Segoe UI Emoji'; ``` - **Serif** ```css font-family: Iowan Old Style,\nApple Garamond, Baskerville, Times New Roman, Droid Serif, Times, Source Serif\nPro, serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol; ``` -\n**Monospace** ```css font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo,\nConsolas, Liberation Mono, monospace; ``` ## 5. Allowlist Config You can reduce\nthe size of your app by only enabling the Tauri API features you need in the\n`allowlist` config. ### Why? The `allowlist` config determines what API features\nto enable; disabled features will **not be compiled into your app**. This is an\neasy way of shedding some extra weight. ### How? An example from a typical\n`tauri.conf.json`: ```json { \"tauri\": { \"allowlist\": { \"all\": false, \"fs\": {\n\"writeFile\": true }, \"shell\": { \"execute\": true }, \"dialog\": { \"save\": true } }\n} } ``` ## 6. Rust Build-time Optimizations Configure your cargo project to take\nadvantage of rusts size optimization features. [Why is a rust executable large\n?] provides an excellent explanation on why this matters and an in-depth\nwalkthrough. At the same time, [Minimizing Rust Binary Size] is more up-to-date\nand has a couple of extra recommendations. ### Why? Rust is notorious for\nproducing large binaries, but you can instruct the compiler to optimize the\nfinal executable's size. ### How? Cargo exposes several options that determine\nhow the compiler generates your binary. The \"recommended\" options for Tauri apps\nare these: ```toml [profile.release] panic = \"abort\" # Strip expensive panic\nclean-up logic codegen-units = 1 # Compile crates one after another so the\ncompiler can optimize better lto = true # Enables link to optimizations\nopt-level = \"s\" # Optimize for binary size ``` :::note There is also `opt-level\n= \"z\"` available to reduce the resulting binary size. `\"s\"` and `\"z\"` can\nsometimes be smaller than the other, so test it with your application! We've\nseen smaller binary sizes from `\"s\"` for Tauri example applications, but\nreal-world applications can always differ. ::: For a detailed explanation of\neach option and a bunch more, refer to the [Cargo books Profiles section][cargo\nprofiles]. ### Unstable Rust Compression Features :::caution The following\nsuggestions are all unstable features and require a nightly toolchain. See the\n[Unstable Features][cargo unstable features] documentation for more information\non what this involves. ::: The following methods involve using unstable compiler\nfeatures and require the rust nightly toolchain. If you don't have the nightly\ntoolchain + `rust-src` nightly component added, try the following: ```sh $\nrustup toolchain install nightly $ rustup component add rust-src --toolchain\nnightly ``` The Rust Standard Library comes precompiled. This means rust is\nfaster to install, but also that the compiler can't optimize the Standard\nLibrary. You can apply the optimization options for the rest of your binary +\ndependencies to the std with an unstable flag. This flag requires specifying\nyour target, so know the target triple you are targeting. ```sh $ cargo +nightly\nbuild --release -Z build-std --target x86_64-unknown-linux-gnu ``` If you are\nusing `panic = \"abort\"` in your release profile optimizations, you need to make\nsure the `panic_abort` crate is compiled with std. Additionally, an extra std\nfeature can further reduce the binary size. The following applies both: ```sh $\ncargo +nightly build --release -Z build-std=std,panic_abort -Z\nbuild-std-features=panic_immediate_abort --target x86_64-unknown-linux-gnu ```\nSee the unstable documentation for more details about [`-Z build-std`][cargo\nbuild-std] and [`-Z build-std-features`][cargo build-std-features]. ## 7.\nStripping Use strip utilities to remove debug symbols from your compiled app.\n### Why? Your compiled app includes so-called \"Debug Symbols\" that include\nfunction and variable names. Your end-users will probably not care about Debug\nSymbols, so this is a pretty surefire way to save some bytes! ### How? The\neasiest way is to use the famous `strip` utility to remove this debugging\ninformation. ```sh $ strip target/release/my_application ``` See your local\n`strip` manpage for more information and flags that can be used to specify what\ninformation gets stripped out from the binary. ## 8. UPX UPX, **Ultimate Packer\nfor eXecutables**, is a dinosaur amongst the binary packers. This 23-year old,\nwell-maintained piece of kit is GPL-v2 licensed with a pretty liberal usage\ndeclaration. Our understanding of the licensing is that you can use it for any\npurposes (commercial or otherwise) without needing to change your license unless\nyou modify the source code of UPX. ### Why? Maybe your target audience has very\nslow internet, or your app needs to fit on a tiny USB stick, and all the above\nsteps haven't resulted in the savings you need. Fear not, as we have one last\ntrick up our sleeves: [UPX] compresses your binary and creates a self-extracting\nexecutable that decompresses itself at runtime. ### How? :::caution You should\nknow that this technique might flag your binary as a virus on Windows and macOS\n- so use at your own discretion, and as always, validate with [Frida] and do\nreal distribution testing! ::: #### Usage on macOS ```sh $ brew install upx $\nyarn tauri build $ upx --ultra-brute\nsrc-tauri/target/release/bundle/macos/app.app/Contents/macOS/app Ultimate Packer\nfor eXecutables Copyright (C) 1996 - 2018 UPX 3.95 Markus Oberhumer, Laszlo\nMolnar & John Reiser Aug 26th 2018 File size Ratio Format Name\n-------------------- ------ ----------- ----------- 963140 -> 274448 28.50%\nmacho/amd64 app ``` [cargo-bloat]: https://github.com/RazrFalcon/cargo-bloat\n[Macros]: https://doc.rust-lang.org/book/ch19-06-macros.html [cargo-expand]:\nhttps://github.com/dtolnay/cargo-expand [rollup-plugin-visualizer]:\nhttps://github.com/btd/rollup-plugin-visualizer [rollup-plugin-graph]:\nhttps://github.com/ondras/rollup-plugin-graph [vite]: https://vitejs.dev\n[webpack]: https://webpack.js.org [rollup]: https://rollupjs.org/guide/en/\n[rollup-plugin-terser]: https://github.com/TrySound/rollup-plugin-terser\n[rollup-plugin-uglify]: https://github.com/TrySound/rollup-plugin-uglify\n[terser]: https://terser.org [esbuild]: https://esbuild.github.io [typescript]:\nhttps://www.typescriptlang.org [moment.js]: https://momentjs.com\n[you-dont-need-momentjs]:\nhttps://github.com/you-dont-need/You-Dont-Need-Momentjs [http archive]:\nhttps://httparchive.org [http archive report, image bytes]:\nhttps://httparchive.org/reports/page-weight#bytesImg [imagemin is unmaintained]:\nhttps://github.com/imagemin/imagemin/issues/385 [gimp]: https://www.gimp.org\n[photoshop]: https://www.adobe.com/de/products/photoshop.html [vite-imagetools]:\nhttps://github.com/JonasKruckenberg/imagetools [vite-plugin-imagemin]:\nhttps://github.com/vbenjs/vite-plugin-imagemin [image-minimizer-webpack-plugin]:\nhttps://github.com/webpack-contrib/image-minimizer-webpack-plugin [squoosh]:\nhttps://squoosh.app [responsive images]:\nhttps://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\n[why is a rust executable large ?]:\nhttps://lifthrasiir.github.io/rustlog/why-is-a-rust-executable-large.html\n[minimizing rust binary size]: https://github.com/johnthagen/min-sized-rust\n[cargo unstable features]:\nhttps://doc.rust-lang.org/cargo/reference/unstable.html#unstable-features [cargo\nprofiles]: https://doc.rust-lang.org/cargo/reference/profiles.html [cargo\nbuild-std]: https://doc.rust-lang.org/cargo/reference/unstable.html#build-std\n[cargo build-std-features]:\nhttps://doc.rust-lang.org/cargo/reference/unstable.html#build-std-features\n[Bundlephobia]: https://bundlephobia.com [Frida]: https://frida.re/docs/home/\n[UPX]: https://github.com/upx/upx","url":"https://tauri.studio/docs/building/app-size"},{"id":"prose_docs_building_cross_platform_md","title":"Cross","area":"building","section":"building","headings":[],"subHeadings":[],"code":[],"text":"# Cross-Platform Compilation How to use GH Action for Building: a glance at\nTauri Action.","url":"https://tauri.studio/docs/building/cross-platform"},{"id":"prose_docs_building_debian_md","title":"Debian packages","area":"building","section":"building","headings":["Bootstrapper","Custom files"],"subHeadings":[],"code":["json"],"text":"# Debian packages Tauri allows your app to be packaged as a `.deb` (Debian\npackage) file. ## Bootstrapper Instead of launching the app directly, you can\nconfigure the bundled app to run a script that tries to expose the environment\nvariables to the app; without that, you'll have trouble using system programs\nbecause the `PATH` environment variable isn't correct. Enable it with the\n[`useBootstrapper`] config. ## Custom files To include custom files to the\ndebian package, you can configure a mapping on `tauri.conf.json > tauri > bundle\n> deb > files` as follows: ```json { \"tauri\": { \"bundle\": { \"deb\": { \"files\": {\n\"/usr/lib/README.md\": \"../README.md\", // copies the README.md file to\n/usr/lib/README.md \"usr/lib/assets\": \"../public/\" // copies the entire public\ndirectory to /usr/lib/assets } } } } } ``` ::note Each `files` object key is the\npath on the Debian package, and the value is a path to a file or directory\nrelative to the `tauri.conf.json` file. ::: [`useBootstrapper`]:\n/docs/api/config#tauri.bundle.deb.useBootstrapper","url":"https://tauri.studio/docs/building/debian"},{"id":"prose_docs_building_introduction_md","title":"Introduction","area":"building","section":"building","headings":[],"subHeadings":[],"code":[],"text":"# Introduction The Tauri Bundler is a Rust harness to compile your binary,\npackage assets, and prepare a final bundle. It will detect your operating system\nand build a bundle accordingly. It currently supports: - Linux: .deb, .appimage\n- macOS: .app, .dmg - Windows: .exe, .msi","url":"https://tauri.studio/docs/building/introduction"},{"id":"prose_docs_building_sidecar_md","title":"Sidecar ","area":"building","section":"building","headings":["Running the sidecar binary on JavaScript","Running the sidecar binary on Rust","Using Node"],"subHeadings":[],"code":["json","bash","javascript","rust"],"text":"# Sidecar (Embedding External Binaries) You may need to embed depending binaries\nto make your application work or prevent users from installing additional\ndependencies (e.g., Node.js or Python). To bundle the binaries of your choice,\nyou can add the `externalBin` property to the `tauri > bundle` object in your\n`tauri.conf.json`. See more about tauri.conf.json configuration\n[here][tauri.bundle]. `externalBin` expects a list of strings targeting binaries\neither with absolute or relative paths. Here is a sample to illustrate the\nconfiguration. This is not a complete `tauri.conf.json` file: ```json { \"tauri\":\n{ \"bundle\": { \"externalBin\": [\"/absolute/path/to/app\",\n\"relative/path/to/binary\", \"bin/python\"] } } } ``` A binary with the same name\nand a `-$TARGET_TRIPLE` suffix must exist on the specified path. For instance,\n`\"externalBin\": [\"bin/python\"]` requires a\n`src-tauri/bin/python-x86_64-unknown-linux-gnu` executable on Linux. You can\nfind the current platform's target triple running the following command: ```bash\nrustc -Vv | grep host | cut -f2 -d' ' ``` Here's a Node.js script to append the\ntarget triple to a binary: ```javascript const execa = require('execa') const fs\n= require('fs') let extension = '' if (process.platform === 'win32') { extension\n= '.exe' } async function main() { const rustInfo = (await execa('rustc',\n['-vV'])).stdout const targetTriple = /host: (\\S+)/g.exec(rustInfo)[1] if\n(!targetTriple) { console.error('Failed to determine platform target triple') }\nfs.renameSync( `src-tauri/binaries/app${extension}`,\n`src-tauri/binaries/app-${targetTriple}${extension}` ) } main().catch((e) => {\nthrow e }) ``` ## Running the sidecar binary on JavaScript On the JavaScript\ncode, import the `Command` class on the `shell` module and use the `sidecar`\nstatic method: ```javascript import { Command } from '@tauri-apps/api/shell' //\nalternatively, use `window.__TAURI__.shell.Command` // `my-sidecar` is the value\nspecified on `tauri.conf.json > tauri > bundle > externalBin` const command =\nCommand.sidecar('my-sidecar') const output = await command.execute() ``` ##\nRunning the sidecar binary on Rust On the Rust code, import the `Command` struct\nfrom the `tauri::api::process` module: ```rust let (mut rx, mut child) =\nCommand::new_sidecar(\"my-sidecar\") .expect(\"failed to create `my-sidecar` binary\ncommand\") .spawn() .expect(\"Failed to spawn sidecar\");\ntauri::async_runtime::spawn(async move { // read events such as stdout while let\nSome(event) = rx.recv().await { if let CommandEvent::Stdout(line) = event {\nwindow .emit(\"message\", Some(format!(\"'{}'\", line))) .expect(\"failed to emit\nevent\"); // write to stdin child.write(\"message from\nRust\\n\".as_bytes()).unwrap(); } } }); ``` ## Using Node.js on a sidecar The\nTauri [sidecar example] demonstrates how to use the sidecar API to run a Node.js\napplication on Tauri. It compiles the Node.js code using [pkg] and uses the\nscripts above to run it. [tauri.bundle]: /docs/api/config#tauri.bundle [sidecar\nexample]: https://github.com/tauri-apps/tauri/tree/dev/examples/sidecar [pkg]:\nhttps://github.com/vercel/pkg","url":"https://tauri.studio/docs/building/sidecar"},{"id":"prose_docs_community_ci_cd_md","title":"CI","area":"community","section":"community","headings":["Continuous Integration","Continuous Deployment"],"subHeadings":["Introduction to immutable checksum","Next Steps"],"code":["yml"],"text":"# CI/CD ## Continuous Integration Github Actions has two triggers we use\nheavily: `push` and `pull_request`. Every commit that is made to the repo is a\n`push`. When you open a pull request from a branch (call it `great_feature`) to\nanother branch (our working branch, `dev`), each commit to `great_feature` would\npossibly trigger both of these events. We can use a filter to focus on the\nevents we care about, however. In our workflows, we only PR (pull request) the\n`dev` and `master` branches. This means that if we filter to only the `dev` and\n`master` branches on commit, we will only run that workflow when we _merge_ a\nPR. A merged PR typically only occurs once a day or less, so this is a good fit\nfor the longer running tests, e.g., the smoke tests in our case. Below is how\nthat might look. Unit tests: ```yml # these run fast so we can have them run on\nany commit name: unit tests on: pull_request: push: branches: - dev - master ```\nSmoke tests: ```yml # these run slower so we run only on merges to dev or master\nbranch name: smoke tests on: push: branches: - dev - master ``` Tauri operates\noff the `dev` branch as default, and merges to `master` for release. With these\nGithub Actions set up, we will run the unit tests on every commit to an open PR\n(see `pull_request`). When that PR is merged into `dev`, we will run both the\nunit tests and the smoke tests. ## Continuous Deployment ### Introduction to\nimmutable checksum It is not only possible, but trivial to modify release notes\nand artifacts after it has been published on Github. While there are very valid\nreasons for doing this, it is not exactly a totally trustworthy method - i.e.\nyou have no guarantee that what you are reading is really reflective of the\nunderlying truth or the tarballs. It is technically possible to change downloads\nover the wire or in the box or change checksums in targeted attacks. What we are\nseeking to accomplish is a best case scenario where: 1. Human error is reduced\nto a minimum, but humans are still integral in the actual release 2. Machine\nbuilt assets, changelogs and attached security audits are verifiable with\nchecksums that are published in an immutable, globally available store. To this\nend we fashioned a workflow shown below. As it stands now, we have #3 through #6\nimplemented. We manually do #2 which then feeds into #3 and kicks off the rest\nof the automatic workflow. 1. a human pushes to dev through a pull request (can\nhappen any number of times) - pull request includes a changeset file describing\nthe change and required version bump 2. a pull request is created (or updated)\nto include the change and version bump - this pull request stays open and will\nbe force pushed until it gets merged (and published) - increase the version\nnumber based on changesets - delete all changeset files 3. a codeowner merges\nthe publish PR to dev (no direct push permissible for anyone) - all tests (unit,\ne2e, smoke tests) are run on the PR - failures prevent the publish so they must\npass before merge 4. merge to dev triggers release sequence - changes are\nsquashed and a PR is opened against master 5. when PR to master is merged... -\nvulnerability audit (crates and yarn) and output saved - checksums and metadata\nand output saved - packages are published on npm/cargo, tarball/zip created -\nrelease is created for each package that had updates (if version isn't changed,\nbuild skips the publish steps) - output from audit/checksums is piped into the\nrelease body - tarball / zip attached to release - async process to publish to\nIOTA tangle (feeless) via release tag [note: still have things to resolve here]\n6. release is complete - master has updated code and tagged - GitHub release has\ntarballs, checksums, and changelog (may have multiple releases if more than one\npackage published) [note: is part of step 2 and is not yet implemented] ### Next\nSteps Next steps may include transferring and publishing the built assets to\nadditional places: 1. Tauri's private verdaccio 2. IPFS 3. PureOS Gitlab 4.\nGitHub Packages We can also do some interesting things like signing our\nreleases, including a hash in the release and/or even publishing this\ninformation on a blockchain that it can be easily verified. Publishing on the\nblockchain is another avenue to increase the confidence that what is seen on\nGitHub matches what you have downloaded. The IOTA foundation created a Github\nAction which will publish a release to their blockchain. This has shown promise,\nbut he gave a couple errors to tackle still.","url":"https://tauri.studio/docs/community/ci-cd"},{"id":"prose_docs_community_contributor_guide_md","title":"Contributor Guide","area":"community","section":"community","headings":["Contribution Flow","Hands"],"subHeadings":["A Note About Contributions to the Rust Libraries"],"code":["sh","json","ini"],"text":"# Contributor Guide todo: make this friendlier and more complete Tauri is a\npolyglot system that uses: - git - Node.js - Rust - GitHub actions It can be\ndeveloped on macOS, Linux, and Windows. ## Contribution Flow 1. File an Issue 2.\nFork the Repository 3. Make Your Changes 4. Make a PR ### A Note About\nContributions to the Rust Libraries When contributing to the Rust libraries\n`tauri`, `tauri-api`, and `tauri-updater`; you want to set up an environment for\nRLS (the Rust Language Server). In the Tauri root directory, there is a\n`.scripts` folder that contains a set of scripts to automate adding a couple\ntemporary environment variables to your shell/terminal. These environment\nvariables point to directories in the test fixture, which prevents RLS from\ncrashing on compile-time. This is a necessary step for setting up a development\nenvironment for Tauri's Rust libraries. ##### _Example Instructions_ 1. Navigate\nto the Tauri Root directory. 2. Execute a script based on your Operating System\nfrom this folder: `.scripts/init_env.bat` for Windows Cmd,\n`.scripts/init_env.ps1` for Windows Powershell, `. .scripts/init_env.sh` for\nLinux/macOS bash (note the first `.` in this command). 3. Open your text\neditor/IDE from this shell/terminal. ## Hands-On Example Let's make a new\nexample. That's a great way to learn. We assume you are on a nixy type of\nenvironment like Linux or macOS and have all of your development dependencies\nlike rust and node already sorted out. ```sh git clone\ngit@github.com:tauri-apps/tauri.git cd tauri/cli/tauri.js yarn mkdir\n../../examples/vanillajs && cd \"$_\" ``` ```json \"tauri:source\": \"node\n../../../cli/tauri.js/bin/tauri\", ``` ```ini [dependencies.tauri] path =\n\"../../../../core/tauri\" features = [ \"all-api\" ] ```","url":"https://tauri.studio/docs/community/contributor-guide"},{"id":"prose_docs_debugging_debugging_md","title":"Debugging","area":"debugging","section":"debugging","headings":["Rust Console","WebView JS Console","Create a Debug Build","Run Your App From the Terminal"],"subHeadings":[],"code":["rust","sh",null],"text":"import Command from '@theme/Command' # Debugging With all the moving pieces in\nTauri, you may run into a problem that requires debugging. There are many\nlocations where error details are printed, and Tauri includes some tools to make\nthe debugging process more straightforward. ## Rust Console The first place to\nlook for errors is in the Rust Console. This is in the terminal where you ran,\ne.g., Tauri dev. You can use the following code to print something to that\nconsole from within a Rust file: ```rust println!(\"Message from Rust: {}\", msg);\n``` Sometimes you may have an error in your Rust code, and the Rust compiler can\ngive you lots of information. If, for example, `tauri dev` crashes, you can\nrerun it like this on Linux and macOS: ```sh RUST_DEBUG=1 tauri dev ``` or like\nthis on MS Windows: ```sh set RUST_DEBUG=1 tauri dev ``` This command gives you\na granular stack trace. Generally speaking, the Rust compiler helps you by\ngiving you detailed information about the issue, such as: ``` error[E0425]:\ncannot find value `sun` in this scope --> src/main.rs:11:5 | 11 | sun +=\ni.to_string().parse::().unwrap(); | ^^^ help: a local variable with a similar\nname exists: `sum` error: aborting due to previous error For more information\nabout this error, try `rustc --explain E0425`. ``` ## WebView JS Console\nRight-click in the WebView, and choose `Inspect Element`. This opens up a\nweb-inspector similar to the Chrome or Firefox dev tools you are used to. ##\nCreate a Debug Build There are cases where you might need to inspect the JS\nconsole in the final bundle, so Tauri provides a simple command to create a\ndebugging bundle: Like the normal build and dev processes, building takes some\ntime the first time you run this command but is significantly faster on\nsubsequent runs. The final bundled app has the development console enabled and\nis placed in `src-tauri/target/debug/bundle`. ## Run Your App From the Terminal\nYou can also run a built app from the terminal, giving you the Rust compiler\nnotes (in case of errors) or your `println` messages. Just find the file\n`src-tauri/target/(release|debug)/[app name]` and either double click it (but be\nwarned, the terminal closes on errors) or just run it in directly in your\nconsole.","url":"https://tauri.studio/docs/debugging/debugging"},{"id":"prose_docs_development_development_cycle_md","title":"Development Cycle","area":"development","section":"development","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Command from '@theme/Command' # Development Cycle ### 1. Start Your Dev\nserver Now that you have everything set up, you should start your application\ndevelopment server provided by your UI framework or bundler (assuming you're\nusing one, of course). :::note Every framework has its development tooling. It\nis outside of the scope of this document to treat them all or keep them up to\ndate. ::: ### 2. Start Tauri Development Window The first time you run this\ncommand, the Rust package manager takes several minutes to download and build\nall the required packages. Since they are cached, subsequent builds are much\nfaster, as only your code needs rebuilding. Once Rust has finished building, the\nwebview opens, displaying your web app. You can make changes to your web app,\nand if your tooling enables it, the webview should update automatically, just\nlike a browser. When you make changes to your Rust files, they are rebuilt\nautomatically, and your app automatically restarts. :::info About Cargo.toml and\nSource Control In your project repository, you SHOULD commit the\n\"src-tauri/Cargo.lock\" along with the \"src-tauri/Cargo.toml\" to git because\nCargo uses the lockfile to provide deterministic builds. As a result, it is\nrecommended that all applications check in their Cargo.lock. You SHOULD NOT\ncommit the \"src-tauri/target\" folder or any of its contents. :::","url":"https://tauri.studio/docs/development/development-cycle"},{"id":"prose_docs_development_security_md","title":"Security","area":"development","section":"development","headings":["Tauri Features to keep you Safer"],"subHeadings":["Secure content loading","Isolation Pattern","Tauri API"],"code":["typescript","rust","json"],"text":"# Security Whether you like it or not, today's applications live in operating\nsystems that can be -- and regularly are -- compromised by any number of\nattacks. When your insecure application is a gateway for such lateral movement\ninto the operating system, you are contributing to the tools that professional\nhackers have at their disposal. Don't be a tool. This is why we have taken every\nopportunity to help you secure your application, prevent undesired access to\nsystem level interfaces, and manufacture bullet-proof applications. Your users\nassume you are following best practices. We make that easy, but you should still\nread up on it below. ## Security Is A Community Responsibility (adapted from\n[Electron][security-is-everyones-responsibility]) It is important to remember\nthat the security of your Tauri application is the result of the overall\nsecurity of Tauri itself, all Rust and NPM dependencies, your code, and the\ndevices that run the final application. The Tauri Team does its best to do its\npart, the security community does its part, and you too would do well to follow\na few important best practices: - **Keep your application up-to-date with the\nlatest Tauri release.** When releasing your app into the wild, you are also\nshipping a bundle that has Tauri in it. Vulnerabilities affecting Tauri may\nimpact the security of your application. By updating Tauri to the latest\nversion, you ensure that critical vulnerabilities are already patched and cannot\nbe exploited in your application. Also be sure to keep your compiler (rustc) and\ntranspilers (nodejs) up to date, because there are often security issues that\nare resolved. - **Evaluate your dependencies.** While NPM and Crates.io provide\nmany convenient packages, it is your responsibility to choose trustworthy\n3rd-party libraries - or rewrite them in Rust. If you do use outdated libraries\naffected by known vulnerabilities or are unmaintained, your application security\nand good-night's sleep could be in jeopardy. Use tooling like `npm audit` and\n`cargo audit` to automate this process and lean on the security community's\nimportant work. - **Adopt more secure coding practices.** The first line of\ndefense for your application is your own code. Although Tauri can protect you\nfrom common web vulnerabilities, such as Cross-Site Scripting based Remote Code\nExecution, improper configurations can have a security impact. Even if this were\nnot the case, it is highly recommended to adopt secure software development best\npractices and perform security testing. We detail what this means in the next\nsection. - **Educate your Users.** True security really means that unexpected\nbehaviour cannot happen. So in a sense, being more secure means having the peace\nof mind in knowing that ONLY those things that you want to happen can happen. In\nthe real world, though, this is a utopian \"dream\". However, by removing as many\nvectors as possible and building on a solid foundation, your choice for Tauri is\na signal to your users that you really care about them, their safety, and their\ndevices. ## Threat Models Tauri applications are composed of many pieces at\ndifferent points of the lifecycle. Here we describe classical threats and what\nyou SHOULD do about them. - **Upstream Threats.** Tauri is a direct dependency\nof your project, and we maintain strict authorial control of commits, reviews,\npull-requests, and releases. We do our best to maintain up-to-date dependencies\nand take action to either update or fork&fix. Other projects may not be so well\nmaintained, and may not even have ever been audited. Please consider their\nhealth when integrating them, because otherwise you may have adopted\narchitectural debt without even knowing it. - **Development Threats.** We assume\nthat you, the developer, care for your development environment like a shrine of\npurity because it is a thing of beauty. It is on you to make sure that your\noperating system, build toolchains, and associated dependencies are kept up to\ndate. A very real risk all of us face is what is known as \"supply-chain\nattacks\", which are usually considered to be attacks on direct dependencies of\nyour project. However, there is a growing class of attacks in the wild that\ndirectly target development machines, and you would be well-off to address these\nhead-on. One practice that we highly recommend, even if it is a bit more time\nintensive, is to only ever consume critical dependencies from git using hash\nrevisions at best or named tags as second best. This holds true for Rust as well\nas the Node ecosystem. Also, consider requiring all contributors to sign their\ncommits and protect GIT branches and pipelines. - **Buildtime Threats.** Modern\norganisations use CI/CD to manufacture binary artifacts. At Tauri, we even\nprovide a Github Workflow for building on multiple platforms. If you create your\nown CI/CD and depend on third-party tooling, be wary of actions whose versions\nyou have not explicitly pinned. You should sign your binaries for the platform\nyou are shipping to, and while this can be complicated and somewhat costly to\nsetup, end-users expect that your app is verifiably from you. - **Runtime\nThreats** We assume the webview is insecure, which has led Tauri to implement\nseveral protections regarding webview access to system APIs in the context of\nloading untrusted userland content. You can read more in detail below, but using\nthe CSP will lockdown types of communication that the Webview can undertake.\nFurthermore, there is a novel \"Isolation\" pattern that prevents untrusted\ncontent or scripts from accessing the API within the Webview. And please,\nwhatever you do, DO NOT trust the results of cryptography using private keys in\nthe Webview. We gave you Rust for a reason. - **Updater Threats** We have done\nour best to make shipping hot-updates to the app as straightforward and secure\nas possible. However, if you lose control of the manifest server, the build\nserver, or the binary hosting service - all bets are off. If you are building\nyour own system, consult a professional OPS architect and build it properly. ##\nAn unsorted list of big ole DONT'S: - DON'T accept content over http:// or ws://\n- DON'T ship an app with the development console enabled - DON'T forget to [read\nabout XSS][XSS] - DON'T ship any kind of localhost server unless the app needs\nto talk to other devices - DON'T consume JS from a CDN without using an\nintegrity checksum ## Security Researchers Nothing is perfect, attack vectors\nwill be found, and if you have found one - we want to know about it. If you have\na discovery, PLEASE DO NOT FILE A PUBLIC ISSUE OR MAKE A PULL REQUEST. Please\ndiscretely reach out to a member of the team via Discord or Email for\nverification, vulnerability acceptance, and remediation timeline. We believe in\n- and participate in - responsible disclosure. At this time we do not have a\nbug-bounty programme in place, but are actively considering it. ## Tauri\nFeatures to keep you Safer ### Secure content loading Tauri restricts the\n[Content Security Policy (CSP)] of your HTML pages. Local scripts are hashed,\nstyles and external scripts are referenced using a cryptographic nonce, which\nprevents unallowed content from being loaded. The CSP protection is only enabled\nif [`tauri.security.csp`] is set on the Tauri configuration file. You should\nmake it as restricted as possible, only allowing the webview to load assets from\nhosts you trust and preferably own. At compile time, Tauri appends its nonces\nand hashes to the relevant CSP attributes automatically, so you only need to\nworry about what is unique to your application. :::note See [script-src][CSP\nscript-src], [style-src][CSP style-src] and [CSP Sources] for more information\nabout this protection. ::: :::note With the CSP protection enabled, using inline\n`style` attributes it not allowed. ::: :::caution Avoid loading remote content\nsuch as scripts served over a CDN as they introduce an attack vector, but any\nuntrusted file can introduce new and subtle attack vectors. ::: ### Isolation\nPattern The [Isolation Pattern] is a way to inject a secondary, ideally minimal,\nJavaScript application in between your frontend application and Tauri Core. This\nminimal Isolation application can then be used to securely verify and modify IPC\nmessages before they reach Tauri Core. The [Isolation Pattern] guide has more\ninformation. ### Tauri API The [Tauri API] provides functions to access common\nnative functionality such as filesystem access, HTTP requests, system\nnotifications and child processes usage. They provide an easy path to JavaScript\ndevelopers to access the operating system, but they should be used carefully.\n#### Prefer specific commands When accessing a native API, you should prefer\nwriting a dedicated command to implement your business logic instead of writing\neverything on the frontend layer. For instance, see the following frontend API\nusage: ```typescript import { writeFile, Dir } from '@tauri-apps/api/fs' await\nwriteFile({ path: 'report.txt', contents: 'the file content' }, { dir: Dir.App,\n}) ``` If you do not enable the [isolation pattern](#Isolation-pattern), an\nattacker with remote code execution can overwrite the contents of `report.txt`\nsince that API is generic and enabled. If you use a dedicated command, this is\nnot an issue: ```rust #[tauri::command] async fn write_report(app:\ntauri::AppHandle) -> Result<(), String> { let app_dir =\napp.path_resolver().app_dir().expect(\"failed to get app dir\"); let report_path =\napp_dir.join(\"report.txt\"); std::fs::write(&report_path, \"the file content\")\n.map_err(|e| e.to_string()); Ok(()) } fn main() { tauri::Builder::default()\n.invoke_handler(tauri::generate_handler![write_report])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ```typescript import { invoke } from\n'@tauri-apps/api/tauri' await invoke('write_report') ``` This example command\nwritten on the backend cannot be exploited. :::note Tauri recommends using the\nwebview as only a user interface layer, keeping important logic on the core\nlayer. ::: #### The allowlist When using the API package, you **must** enable\nonly the interfaces your application is using. See [the allowlist configuration]\nfor options to restrict which APIs are enabled. This not only reduces surface\narea, but also treeshakes out unneeded functionality -- which reduces final\nbinary size. #### API scoping Some API modules provides a configuration to scope\nthe API access and restrict the system resources accessed. ##### Filesystem You\ncan restrict the folders and files that can be accessed when using the `fs`\nmodule. The scope array lists what paths are allowed using glob patterns and\npredefined variables that resolves to a system base directory. :::note The\nvariables are: `$AUDIO`, `$CACHE`, `$CONFIG`, `$DATA`, `$LOCALDATA`, `$DESKTOP`,\n`$DOCUMENT`, `$DOWNLOAD`, `$EXE`, `$FONT`, `$HOME`, `$PICTURE`, `$PUBLIC`,\n`$RUNTIME`, `$TEMPLATE`, `$VIDEO`, `$RESOURCE`, `$APP` and `$CWD`. ::: ```json {\n\"tauri\": { \"allowlist\": { \"fs\": { \"scope\": [\"$APP/db/*\", \"$RESOURCE/check.png\"]\n} } } } ``` ###### Asset protocol You can restrict the folders and files that\ncan be accessed when using the `asset` protocol. The scope array has the same\nsyntax as the `fs` scope array: ```json { \"tauri\": { \"allowlist\": { \"path\": {\n\"all\": true }, \"protocol\": { \"asset\": true, \"assetScope\": ['$APP/assets/*'] } }\n} } ``` ```typescript import { appDir, join } from '@tauri-apps/api/path' import\n{ convertFileSrc } from '@tauri-apps/api/tauri' const appDirPath = await\nappDir() // this path is allowed - is matches $APP/assets/* // you can use this\non tags or window.fetch() calls const allowedPath = convertFileSrc(await\njoin(appDirPath, 'assets', 'tauri.mp4')) // this path is not allowed - it does\nnot match $APP/assets/* const disallowedPath = convertFileSrc(await\njoin(appDirPath, 'tauri.mp4')) ``` ###### HTTP You can restrict the URLs and\npaths that can be accessed when using the `http` module: ```json { \"tauri\": {\n\"allowlist\": { \"http\": { \"scope\": [\"https://api.github.com/repos/tauri-apps/*\"]\n} } } } ``` ```typescript import { fetch } from '@tauri-apps/api/http' // this\npromise is resolved await fetch('https://api.github.com/repos/tauri-apps/tauri')\n// this promise is rejected - the URL is not allowed on the scope await\nfetch('https://api.github.com/repos/electron/electron') ``` ###### Shell To\nprevent unrestricted access to process spawning, Tauri offers a configuration to\ndefine programs and command line arguments that are allowed to be used. While it\ncan make userland ergonomics less simple, is good security hygiene to lock down\nshell commands from spawning other, unexpected commands. ```json { \"tauri\": {\n\"allowlist\": { \"shell\": { \"scope\": [ { \"name\": \"install-dep\", \"cmd\": \"apt-get\",\n\"args\": [ \"install\", { \"validator\": \"(gcc|rustc)$\" } ] } ], // allows using the\n`open` API only using arguments that match this regex // `true` is also a valid\nvalue, which defines the regex as `https?://`. \"open\":\n\"^https://github.com/tauri-apps/\" } } } } ``` ```typescript import { Command,\nopen } from '@tauri-apps/api/shell' // this command is allowed new\nCommand('install-dep', ['install', 'rustc']).spawn() // this command is not\nfound - does not match the `name` value of the scope definition new\nCommand('install-my-dep', ['install', 'rustc']).spawn() // this command is\nrejected - does not match validator regex for the second argument new\nCommand('install-dep', ['install', 'tar']).spawn() // this command is rejected -\nextra argument new Command('install-dep', ['install', 'rustc', '-y']).spawn() //\nthis open() usage is allowed because it matches the `open` regex await\nopen('https://github.com/tauri-apps/tauri') // this open() call is rejected -\ndoes not match validator regex open('https://docs.rs/tauri/latest/tauri') ```\n[security-is-everyones-responsibility]:\nhttps://www.electronjs.org/docs/latest/tutorial/security#security-is-everyones-responsibility\n[XSS]: https://owasp.org/www-community/attacks/xss/ [Content Security Policy\n(CSP)]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\n[`tauri.security.csp`]: /docs/api/config/#tauri.security.csp [CSP script-src]:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src\n[CSP style-src]:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/style-src\n[CSP Sources]:\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources#sources\n[Isolation Pattern]: docs/architecture/patterns/isolation [Tauri API]:\nhttps://www.npmjs.com/package/@tauri-apps/api [the allowlist configuration]:\n/docs/api/config/#tauri.allowlist","url":"https://tauri.studio/docs/development/security"},{"id":"prose_docs_development_updating_dependencies_md","title":"Updating Dependencies","area":"development","section":"development","headings":["Automatic updates","Manual updates"],"subHeadings":["Update NPM Packages"],"code":[],"text":"# Updating Dependencies :::caution Please note Especially during the alpha and\nbeta phases, we expect you to keep all Tauri dependencies and toolchains up to\ndate. There is no support for any versions other than latest. ::: ## Automatic\nupdates The Tauri JS CLI has a command to install and update all needed\ndependencies, just run `tauri deps install` or `tauri deps update`. ## Manual\nupdates ### Update NPM Packages If you are using the `tauri` package: ```bash $\nyarn upgrade @tauri-apps/cli @tauri-apps/api --latest $ npm install\n@tauri-apps/cli@latest @tauri-apps/api@latest ``` You can also detect what the\nlatest version of Tauri is on the command line, using: - `npm outdated\n@tauri-apps/cli` - `yarn outdated @tauri-apps/cli` Alternatively, if you are\nusing the `vue-cli-plugin-tauri` approach: ```bash $ yarn upgrade\nvue-cli-plugin-tauri --latest $ npm install vue-cli-plugin-tauri@latest ``` ###\nUpdate Cargo Packages Go to `src-tauri/Cargo.toml` and change `tauri` to `tauri\n= { version = \"%version%\" }` where `%version%` is the version number shown\nabove. (You can just use the `MAJOR.MINOR`) version, like `0.9`. Then do the\nfollowing: ```bash $ cd src-tauri $ cargo update -p tauri ``` You can also run\n`cargo outdated -r tauri` to get direct information about the core library's\nlatest version.","url":"https://tauri.studio/docs/development/updating-dependencies"},{"id":"prose_docs_distribution_linux_md","title":"Linux Application Distribution","area":"distribution","section":"distribution","headings":["Limitations","Debian","AppImage"],"subHeadings":[],"code":["json"],"text":"# Linux Application Distribution Tauri applications for Linux are distributed\neither with a [Debian package] (a file with the `.deb` extension) or as an\n[AppImage] when building using the Tauri CLI. ## Limitations Core libraries such\nas glibc frequently break compatibility with older systems. For this reason, you\nmust build your Tauri application using the oldest base system you intend to\nsupport. A relatively old system such as Ubuntu 18.04 is more suited than Ubuntu\n21.04, as the binary compiled on Ubuntu 21.04 will have a higher requirement of\nthe glibc version, so when running on an older system, you will face a runtime\nerror like `/usr/lib/libc.so.6: version 'GLIBC_2.33' not found`. We recommend\nusing a Docker container or GitHub Actions to build your Tauri application for\nLinux. See the issues [rust-lang/rust#1355] and [rust-lang/rust#57497], in\naddition to the [AppImage guide] for more information. ## Debian The stock\nDebian package generated by the Tauri bundler has everything you need to ship\nyour application to Debian-based Linux distributions, defining your\napplication's icons, generating a Desktop file, and specifying the dependencies\n`libwebkit2gtk-4.0-37` and `libgtk-3-0`, along with `libappindicator3-1` if your\napp uses the system tray. If you need extended control over the Debian package,\nyou can provide a list of folders or files to move to the package. The\nconfiguration object maps the path in the Debian package to the path to the file\non your filesystem, relative to the core binary crate folder (`./src-tauri` by\ndefault). Here's an example configuration: ```json { \"tauri\": { \"bundle\": {\n\"deb\": { \"files\": { \"usr/share/my-app\": \"../assets/\", // copy the entire assets\ndirectory to /usr/share/my-app \"/usr/share/doc/my-app/README.md\":\n\"../README.md\", // copy a single file } } } } } ``` ## AppImage AppImage is a\ndistribution format that does not rely on the system installed packages and\ninstead bundles all dependencies and files needed by the application. For this\nreason, the output file is larger but easier to distribute since it is supported\non many Linux distributions and can be executed without installation, just\nmaking the file executable (`$ chmod a+x MyProject.AppImage`) and running it\n(`./MyProject.AppImage`). AppImages are convenient, simplifying the distribution\nprocess if you cannot make a package targeting the distribution's package\nmanager. Still, you should carefully use it as the file size grows from the\n2-6MBs range to 70+MBs. [Debian Package]: https://wiki.debian.org/Packaging\n[AppImage]: https://appimage.org/ [rust-lang/rust#1355]:\nhttps://github.com/tauri-apps/tauri/issues/1355 [rust-lang/rust#57497]:\nhttps://github.com/rust-lang/rust/issues/57497 [AppImage guide]:\nhttps://docs.appimage.org/reference/best-practices.html#binaries-compiled-on-old-enough-base-system","url":"https://tauri.studio/docs/distribution/linux"},{"id":"prose_docs_distribution_macos_md","title":"macOS Application Distribution","area":"distribution","section":"distribution","headings":["Minimum system version","Binary targets","Application bundle customization","Code signing and notarization"],"subHeadings":[],"code":[],"text":"# macOS Application Distribution Tauri applications for macOS are distributed\neither with an [Application Bundle] (`.app` files) or an Apple Disk Image\n(`.dmg` files). The Tauri CLI automatically bundles your application code in\nthese formats, providing options to codesign and notarize your application. ##\nMinimum system version The minimum version of the operating system required for\na Tauri app to run in macOS is `10.13`. You can change that value on the\n[`tauri.bundle.macOS.minimumSystemVersion`] property. The value is set to the\nInfo.plist key [LSMinimumSystemVersion] and the MACOSX_DEPLOYMENT_TARGET\nenvironment variable. :::note macOS High Sierra (10.13) no longer receives\nsecurity updates from Apple. You should target macOS Catalina (10.15) if\npossible. ::: :::caution Using the `window.print` API requires macOS version\n`11.0+`. ::: ## Binary targets You can compile your application targeting Apple\nSilicon, Intel-based Mac computers, or universal macOS binaries. By default, the\nCLI builds a binary targetting your machine's architecture. If you are using an\nApple Silicon macOS, you can compile Intel and universal binaries using the\n`target` option: - `tauri build --target aarch64-apple-darwin`: targets Apple\nSilicon for your application; - `tauri build --target x86_64-apple-darwin`:\ntargets Intel-based Mac computers; - `tauri build --target\nuniversal-apple-darwin`: targets [universal macOS binaries]. :::caution - Apple\nSilicon binaries only run on Mac computers with Apple Silicon. - Intel-based\nbinaries only run on Intel-based Mac computers and Apple Silicon computers under\nthe Rosetta translation. - Universal macOS binaries run on both architectures.\n::: ## Application bundle customization The Tauri configuration file provides\nthe following options to customize your application bundle: - **Bundle name**:\n[`package.productName`]. - **Bundle version**: [`package.version`]. -\n**Application category**: [`tauri.bundle.category`]. - **Copyright**:\n[`tauri.bundle.copyright`]. - **Bundle icon**: first `.icns` file listed on the\n[`tauri.bundle.icon`] array. - **Minimum system version**:\n[`tauri.bundle.macOS.minimumSystemVersion`]. - **DMG license file**:\n[`tauri.bundle.macOS.license`]. - **[Entitlements.plist file]**:\n[`tauri.bundle.macOS.entitlements`]. - **Exception domain**: an insecure domain\nthat your application can access such as a `localhost` or a remote `http`\ndomain. It is a convenience configuration around `NSAppTransportSecurity >\nNSExceptionDomains` setting `NSExceptionAllowsInsecureHTTPLoads` and\n`NSIncludesSubdomains` to true. See [`tauri.bundle.macOS.exceptionDomain`]. -\n**Bootstrapper**: Instead of launching the app directly, you can configure the\nbundled app to run a script that tries to expose the environment variables to\nthe app; without that, you'll have trouble using system programs because the\n`PATH` environment variable isn't correct. Enable it with\n[`tauri.bundle.macOS.useBootstrapper`]. :::note These options generate the\napplication bundle [Info.plist file]. You can extend the generated file with\nyour own `Info.plist` file stored on the Tauri folder (`src-tauri` by default).\nThe CLI merges both `.plist` files on production, and the core layer embeds it\non the binary on development. ::: ## Code signing and notarization See the [Code\nsigning guide]. [Application Bundle]:\nhttps://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html\n[`tauri.bundle.macOS.minimumSystemVersion`]:\n/docs/api/config#tauri.bundle.macOS.minimumSystemVersion\n[LSMinimumSystemVersion]:\nhttps://developer.apple.com/documentation/bundleresources/information_property_list/lsminimumsystemversion\n[universal macOS binaries]:\nhttps://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary\n[`package.productName`]: /docs/api/config/#package.productName\n[`package.version`]: /docs/api/config/#package.version\n[`tauri.bundle.category`]: /docs/api/config/#tauri.bundle.category\n[`tauri.bundle.copyright`]: /docs/api/config/#tauri.bundle.copyright\n[`tauri.bundle.icon`]: /docs/api/config/#tauri.bundle.icon\n[`tauri.bundle.macOS.minimumSystemVersion`]:\n/docs/api/config/#tauri.bundle.macOS.minimumSystemVersion\n[`tauri.bundle.macOS.license`]: /docs/api/config/#tauri.bundle.macOS.license\n[Entitlements.plist file]:\nhttps://developer.apple.com/documentation/bundleresources/entitlements\n[`tauri.bundle.macOS.entitlements`]:\n/docs/api/config/#tauri.bundle.macOS.entitlements\n[`tauri.bundle.macOS.exceptionDomain`]:\n/docs/api/config/#tauri.bundle.macOS.exceptionDomain\n[`tauri.bundle.macOS.useBootstrapper`]:\n/docs/api/config#tauri.bundle.deb.useBootstrapper [Info.plist file]:\nhttps://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html\n[Code signing guide]: ./sign-macos.md","url":"https://tauri.studio/docs/distribution/macos"},{"id":"prose_docs_distribution_publishing_md","title":"App Publishing","area":"distribution","section":"distribution","headings":[],"subHeadings":["1","2"],"code":[],"text":"import Command from '@theme/Command' # App Publishing ### 1. Build Your Web App\nNow that you are ready to package your project, you need to run your framework's\nor bundler's build command (assuming you're using one, of course). :::note Every\nframework has its publishing tooling. It is outside of the scope of this\ndocument to treat them all or keep them up to date. ::: ### 2. Bundle your\napplication with Tauri This command embeds your web assets into a single binary\nwith your Rust code. The binary itself will be located in\n`src-tauri/target/release/[app name]`, and installers will be located in\n`src-tauri/target/release/bundle/`. Like the `tauri dev` command, the first time\nyou run this, it takes some time to collect the Rust crates and build everything\n- but on subsequent runs, it only needs to rebuild your app's code, which is\nmuch quicker.","url":"https://tauri.studio/docs/distribution/publishing"},{"id":"prose_docs_distribution_sign_macos_md","title":"Code Signing macOS Applications","area":"distribution","section":"distribution","headings":["Requirements","tl","Signing Tauri apps"],"subHeadings":["Creating a signing certificate","Downloading a certificate","Signing the Tauri application","Building the application","Example"],"code":["yml"],"text":"# Code Signing macOS Applications This guide provides information on code\nsigning and notarization for macOS applications. :::note If you are not\nutilizing GitHub Actions to perform builds of OSX DMGs, you will need to ensure\nthe environment variable CI=true exists. For more information refer to\n[tauri-apps/tauri#592]. ::: ## Requirements - Xcode 11 or above. - An Apple\nDeveloper account enrolled in the [Apple Developer Program]. ## tl;dr The Tauri\ncode signing and notarization process is configured through the following\nenvironment variables: - `APPLE_SIGNING_IDENTITY`: the name of the keychain\nentry that contains the signing certificate. - `APPLE_CERTIFICATE`: base64\nstring of the `.p12` certificate, exported from the keychain. Useful if you\ndon't have the certificate on the keychain (e.g., CI machines). -\n`APPLE_CERTIFICATE_PASSWORD`: the password for the `.p12` certificate. -\n`APPLE_ID` and `APPLE_PASSWORD`: your Apple account email and an [app-specific\npassword]. Only required to notarize the app. - `APPLE_API_ISSUER` and\n`APPLE_API_KEY`: authentication with an App Store Connect API key instead of the\nApple ID. Only required if you notarize the app. ## Signing Tauri apps The first\nstep to sign a macOS application is getting a signing certificate from the Apple\nDeveloper Program. ### Creating a signing certificate To create a new signing\ncertificate, you must generate a Certificate Signing Request (CSR) file from\nyour Mac computer. [Create a certificate signing request] describes creating a\nCSR. On your Apple Developer account, navigate to the [Certificates, IDs &\nProfiles page] and click on the `Add` button to open the interface to create a\nnew certificate. Choose the appropriate certificate type (`Apple Distribution`\nto submit apps to the App Store, and `Developer ID Application` to ship apps\noutside the App Store). Upload your CSR, and the certificate will be created.\n:::note Only the Apple Developer `Account Holder` can create *Developer ID\nApplication* certificates. But it can be associated with a different Apple ID by\ncreating a CSR with a different user email address. ::: ### Downloading a\ncertificate On [Certificates, IDs & Profiles page], click on the certificate you\nwant to use and click on the `Download` button. It saves a `.cer` file that\ninstalls the certificate on the keychain once opened. The name of the keychain\nentry represents the `signing identity`, which can also be found by executing `$\nsecurity find-identity -v -p codesigning`. :::note A signing certificate is only\nvalid if associated with your Apple ID. An invalid certificate won't be listed\non the Keychain Access > My Certificates tab or the $ security find-identity -v\n-p codesigning output. ::: ### Signing the Tauri application The signing\nconfiguration is provided to the Tauri bundler via environment variables. You\nneed to configure the certificate to use and an optional authentication\nconfiguration to notarize the application. #### Certificate environment\nvariables - `APPLE_SIGNING_IDENTITY`: this is the `signing identity` we\nhighlighted above. It must be defined to sign apps both locally and on CI\nmachines. Additionally, to simplify the code signing process on CI, Tauri can\ninstall the certificate on the keychain for you if you define the\n`APPLE_CERTIFICATE` and `APPLE_CERTIFICATE_PASSWORD` environment variables. 1.\nOpen the `Keychain Access` app and find your certificate's keychain entry. 2.\nExpand the entry, double click on the key item, and select `Export \"$KEYNAME\"`.\n3. Select the path to save the `.p12` file and define the exported certificate\npassword. 4. Convert the `.p12` file to base64 running the following script on\nthe terminal: `openssl base64 -in /path/to/certificate.p12 -out\ncertificate-base64.txt`. 5. Set the contents of the `certificate-base64.txt`\nfile to the `APPLE_CERTIFICATE` environment variable. 6. Set the certificate\npassword to the `APPLE_CERTIFICATE_PASSWORD` environment variable. ####\nAuthentication environment variables These variables are only required to\nnotarize the application. :::note Notarization is required when using a\nDeveloper ID Application certificate. ::: - `APPLE_ID` and `APPLE_PASSWORD`: to\nauthenticate with your Apple ID, set the `APPLE_ID` to your Apple account email\n(example: `export APPLE_ID=tauri@icloud.com`) and the `APPLE_PASSWORD` to an\n[app-specific password] for the Apple account. - `APPLE_API_ISSUER` and\n`APPLE_API_KEY`: alternatively, you can authenticate using an App Store Connect\nAPI key. Open the App Store Connect's [Users and Access page], select the `Keys`\ntab, click on the `Add` button and select a name and the `Developer` access. The\n`APPLE_API_ISSUER` (`Issuer ID`) is presented above the keys table, and the\n`APPLE_API_KEY` is the value on the `Key ID` column on that table. You also need\nto download the private key, which can only be done once and is only visible\nafter a page reload (the button is shown on the table row for the newly created\nkey). The private key file must be saved on `./private_keys`, `~/private_keys`,\n`~/.private_keys` or `~/.appstoreconnect/private_keys`, as stated on the `$\nxcrun altool --help` command. ### Building the application The Tauri bundler\nautomatically signs and notarizes your application with all these environment\nvariables set when running the `tauri build` command. ### Example The following\nexample uses GitHub Actions to sign an application using the [Tauri action]. We\nfirst define the environment variables we listed above as Secrets on GitHub.\n:::note You can view this guide\n[https://docs.github.com/en/actions/reference/encrypted-secrets] to learn about\nGitHub secrets. ::: Once we have established the GitHub Secrets, we create a\nGitHub publish workflow in `.github/workflows/main.yml`: ```yml name: \"publish\"\non: push: branches: - release jobs: publish-tauri: strategy: fail-fast: false\nmatrix: platform: [macos-latest] runs-on: ${{ matrix.platform }} steps: - uses:\nactions/checkout@v2 - name: setup node uses: actions/setup-node@v2 with:\nnode-version: 12 - name: install Rust stable uses: actions-rs/toolchain@v1 with:\ntoolchain: stable - name: install app dependencies and build it run: yarn &&\nyarn build - uses: tauri-apps/tauri-action@v0 env: GITHUB_TOKEN: ${{\nsecrets.GITHUB_TOKEN }} ENABLE_CODE_SIGNING: ${{ secrets.APPLE_CERTIFICATE }}\nAPPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }} APPLE_CERTIFICATE_PASSWORD:\n${{ secrets.APPLE_CERTIFICATE_PASSWORD }} APPLE_SIGNING_IDENTITY: ${{\nsecrets.APPLE_IDENTITY_ID }} APPLE_ID: ${{ secrets.APPLE_ID }} APPLE_PASSWORD:\n${{ secrets.APPLE_PASSWORD }} with: tagName: app-v__VERSION__ # the action\nautomatically replaces \\_\\_VERSION\\_\\_ with the app version releaseName: \"App\nv__VERSION__\" releaseBody: \"See the assets to download this version and\ninstall.\" releaseDraft: true prerelease: false ``` The workflow pulls the\nsecrets from GitHub and defines them as environment variables before building\nthe application using the Tauri action. The output is a GitHub release with the\nsigned and notarized macOS application. [tauri-apps/tauri#592]:\nhttps://github.com/tauri-apps/tauri/issues/592 [Apple Developer Program]:\nhttps://developer.apple.com/programs/ [app-specific password]:\nhttps://support.apple.com/en-ca/HT204397 [Create a certificate signing request]:\nhttps://help.apple.com/developer-account/#/devbfa00fef7 [Certificates, IDs &\nProfiles page]: https://developer.apple.com/account/resources/certificates/list\n[Users and Access page]: https://appstoreconnect.apple.com/access/users [Tauri\naction]: https://github.com/tauri-apps/tauri-action","url":"https://tauri.studio/docs/distribution/sign-macos"},{"id":"prose_docs_distribution_sign_windows_md","title":"Windows ","area":"distribution","section":"distribution","headings":["Intro","Prerequisites","Getting Started","Prepare ","BONUS"],"subHeadings":["A","B","C","GitHub Secrets","Workflow Modifications"],"code":[null],"text":"# Windows - Code signing guide locally & with Github Actions ## Intro Code\nsigning your application lets users know that they downloaded the official\nexecutable of your app and not some 3rd party malware that poses as your app.\nWhile it is not required, it improves users' confidence in your app. ##\nPrerequisites - Windows - you can likely use other platforms, but this tutorial\nuses Powershell native features. - Code signing certificate - you can acquire\none of these on services such as Digicert.com, Comodo.com, & Godaddy.com. In\nthis guide, we are using Comodo.com - A working Tauri application ## Getting\nStarted There are a few things we have to do to get Windows prepared for code\nsigning. This includes converting our certificate to a specific format,\ninstalling this certificate, and decoding required information from the\ncertificate. ### A. Convert your `.cer` to `.pfx` 1. You will need the\nfollowing: - certificate file (mine is `cert.cer`) - private key file (mine is\n`private-key.key`) 2. Open up a command prompt and change to your current\ndirectory using `cd Documents/Certs` 3. Convert your `.cer` to a `.pfx` using\n`openssl pkcs12 -export -in cert.cer -inkey private-key.key -out\ncertificate.pfx` 4. You should be prompted to enter an export password **DON'T\nFORGET IT!** ### B. Import your `.pfx` file into the keystore. We now need to\nimport our `.pfx` file. 1. Assign your export password to a variable using\n`$WINDOWS_PFX_PASSWORD = 'MYPASSWORD'` 2. Now Import the certificate using\n`Import-PfxCertificate -FilePath Certs/certificate.pfx -CertStoreLocation\nCert:\\CurrentUser\\My -Password (ConvertTo-SecureString -String\n$env:WINDOWS_PFX_PASSWORD -Force -AsPlainText)` ### C. Prepare Variables 1. We\nneed the SHA-1 thumbprint of the certificate; you can get this using `openssl\npkcs12 -info -in certificate.pfx` and look under for following ``` Bag\nAttributes localKeyID: A1 B1 A2 B2 A3 B3 A4 B4 A5 B5 A6 B6 A7 B7 A8 B8 A9 B9 A0\nB0 ``` 2. You will capture the `localKeyID` but with no spaces, in this example\nit would be `A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0`. This is our\n`certificateThumbprint`. 3. We need the SHA digest algorithm used for your\ncertificate (Hint: this is likely `sha256` 4. We also need a timestamp URL; this\nis a time server used to verify the time of the certificate signing. I'm using\n`http://timestamp.comodoca.com`, but whomever you got your certificate from\nlikely has one as well. ## Prepare `tauri.conf.json` file 1. Now that we have\nour `certificateThumbprint`, `digestAlgorithm`, & `timestampUrl` we will open up\nthe `tauri.conf.json`. 2. In the `tauri.conf.json` you will look for the `tauri`\n-> `bundle` -> `windows` section. You see, there are three variables for the\ninformation we have captured. Fill it out like below. ``` \"windows\": {\n\"certificateThumbprint\": \"A1B1A2B2A3B3A4B4A5B5A6B6A7B7A8B8A9B9A0B0\",\n\"digestAlgorithm\": \"sha256\", \"timestampUrl\": \"http://timestamp.comodoca.com\" }\n``` 3. Save and run `yarn | yarn build` 4. In the console output, you should see\nthe following output. ``` info: signing app info: running signtool \"C:\\\\Program\nFiles (x86)\\\\Windows Kits\\\\10\\\\bin\\\\10.0.19041.0\\\\x64\\\\signtool.exe\" info: \"Done\nAdding Additional Store\\r\\nSuccessfully signed: APPLICATION FILE PATH HERE ```\nWhich shows you have successfully signed the `.exe`. And that's it! You have\nsuccessfully signed your .exe file. ## BONUS: Sign your application with GitHub\nActions. We can also create a workflow to sign the application with GitHub\nactions. ### GitHub Secrets We need to add a few GitHub secrets for the proper\nconfiguration of the GitHub Action. These can be named however you would like. -\nYou can view [this][Encrypted Secrets] guide for how to add GitHub secrets. The\nsecrets we used are as follows | GitHub Secrets | Value for Variable | |\n:--------------------------: |\n:-------------------------------------------------------------------------------------------------------------------------------:\n| | WINDOWS_CERTIFICATE | Base64 encoded version of your .pfx certificate, can\nbe done using this command `certutil -encode certificate.pfx base64cert.txt` | |\nWINDOWS_CERTIFICATE_PASSWORD | Certificate export password used on creation of\ncertificate .pfx | ### Workflow Modifications 1. We need to add a step in the\nworkflow to import the certificate into the Windows environment. This workflow\naccomplishes the following 1. Assign GitHub secrets to environment variables 2.\nCreate a new `certificate` directory 3. Import `WINDOWS_CERTIFICATE` into\ntempCert.txt 4. Use `certutil` to decode the tempCert.txt from base64 into a\n`.pfx` file. 5. Remove tempCert.txt 6. Import the `.pfx` file into the Cert\nstore of Windows & convert the `WINDOWS_CERTIFICATE_PASSWORD` to a secure string\nto be used in the import command. 2. We be using the `tauri-action` publish\ntemplate available [here][Tauri Action]. ``` name: \"publish\" on: push: branches:\n- release jobs: publish-tauri: strategy: fail-fast: false matrix: platform:\n[macos-latest, ubuntu-latest, windows-latest] runs-on: ${{ matrix.platform }}\nsteps: - uses: actions/checkout@v2 - name: setup node uses:\nactions/setup-node@v1 with: node-version: 12 - name: install Rust stable uses:\nactions-rs/toolchain@v1 with: toolchain: stable - name: install webkit2gtk\n(ubuntu only) if: matrix.platform == 'ubuntu-latest' run: | sudo apt-get update\nsudo apt-get install -y webkit2gtk-4.0 - name: install app dependencies and\nbuild it run: yarn && yarn build - uses: tauri-apps/tauri-action@v0 env:\nGITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: tagName: app-v__VERSION__ # the\naction automatically replaces \\_\\_VERSION\\_\\_ with the app version releaseName:\n\"App v__VERSION__\" releaseBody: \"See the assets to download this version and\ninstall.\" releaseDraft: true prerelease: false ``` 3. Right above `-name:\ninstall app dependencies and build it` you will want to add the following step\n``` - name: import windows certificate if: matrix.platform == 'windows-latest'\nenv: WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}\nWINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }} run: |\nNew-Item -ItemType directory -Path certificate Set-Content -Path\ncertificate/tempCert.txt -Value $env:WINDOWS_PFX certutil -decode\ncertificate/tempCert.txt certificate/certificate.pfx Remove-Item -path\ncertificate -include tempCert.txt Import-PfxCertificate -FilePath\ncertificate/certificate.pfx -CertStoreLocation Cert:\\CurrentUser\\My -Password\n(ConvertTo-SecureString -String $env:WINDOWS_PFX_PASSWORD -Force -AsPlainText)\n``` 4. Save and push to your repo. 5. Your workflow can now import your windows\ncertificate and import it into the GitHub runner, allowing for automated\ncode-signing! [Encrypted Secrets]:\nhttps://docs.github.com/en/actions/reference/encrypted-secrets [Tauri Action]:\nhttps://github.com/tauri-apps/tauri-action","url":"https://tauri.studio/docs/distribution/sign-windows"},{"id":"prose_docs_distribution_updater_md","title":"Updater","area":"distribution","section":"distribution","headings":["Configuration","Server Support","Bundler ","Signing updates"],"subHeadings":["Update Requests","Built","Javascript API","Events","Update Server JSON Format","Update File JSON Format","macOS","Windows","Linux"],"code":["js","json","none","bash"],"text":"# Updater ## Configuration Once you have your Tauri project ready, you need to\nconfigure the updater. Add this in tauri.conf.json ```json \"updater\": {\n\"active\": true, \"endpoints\": [\n\"https://releases.myapp.com/{{target}}/{{current_version}}\" ], \"dialog\": true,\n\"pubkey\": \"\" } ``` The required keys are \"active\" and \"endpoints\"; others are\noptional. \"active\" must be a boolean. By default, it's set to false. \"endpoints\"\nmust be an array. The string `{{target}}` and `{{current_version}}` are\nautomatically replaced in the URL allowing you determine\n[server-side](#update-server-json-format) if an update is available. If multiple\nendpoints are specified, the updater will fallback if a server is not responding\nwithin the pre-defined timeout. \"dialog\" if present must be a boolean. By\ndefault, it's set to true. If enabled, [events](#events) are turned off as the\nupdater handles everything. If you need the custom events, you MUST turn off the\nbuilt-in dialog. \"pubkey\" if present, must be a valid public-key generated with\nTauri CLI. See [Signing updates](#signing-updates). ### Update Requests Tauri is\nindifferent to the request the client application provides for update checking.\n`Accept: application/json` is added to the request headers because Tauri is\nresponsible for parsing the response. For the requirements imposed on the\nresponses and the body format of an update, response see [Server\nSupport](#server-support). Your update request must *at least* include a version\nidentifier so that the server can determine whether an update for this specific\nversion is required. It may also include other identifying criteria, such as\noperating system version, to allow the server to deliver as fine-grained an\nupdate as you would like. How you include the version identifier, or other\ncriteria is specific to the server from which you request updates. A common\napproach is to use query parameters, [Configuration](#configuration) shows an\nexample. ### Built-in dialog By default, the updater uses a built-in dialog API\nfrom Tauri. ![New Update](https://i.imgur.com/UMilB5A.png) The dialog release\nnotes are represented by the update `note` provided by the\n[server](#server-support). If the user accepts, the update is downloaded and\ninstalled. Afterward, the user is prompted to restart the application. ###\nJavascript API :::caution You need to _disable built-in dialog_ in your [tauri\nconfiguration](#configuration); Otherwise, the javascript API will NOT work. :::\n```js import { checkUpdate, installUpdate } from \"@tauri-apps/api/updater\";\nimport { relaunch } from \"@tauri-apps/api/process\"; try { const {shouldUpdate,\nmanifest} = await checkUpdate(); if (shouldUpdate) { // display dialog await\ninstallUpdate(); // install complete, restart app await relaunch(); } }\ncatch(error) { console.log(error); } ``` ### Events :::caution You need to\n*disable the built-in dialog* in your [tauri configuration](#configuration);\nOtherwise, events aren't emitted. ::: To know when an update is ready to be\ninstalled, you can subscribe to these events: #### Initialize updater and check\nif a new version is available ##### If a new version is available, the event\n`tauri://update-available` is emitted. Event: `tauri://update` #### Rust ```rust\nwindow.emit(\"tauri://update\".to_string(), None); ``` #### Javascript ```js\nimport { emit } from \"@tauri-apps/api/event\"; emit(\"tauri://update\"); ``` ####\nListen New Update Available Event: `tauri://update-available` Emitted data:\n```none version Version announced by the server date Date announced by the\nserver body Note announced by the server ``` #### Rust ```rust\nwindow.listen(\"tauri://update-available\".to_string(), move |msg| { println!(\"New\nversion available: {:?}\", msg); }) ``` #### Javascript ```js import { listen }\nfrom \"@tauri-apps/api/event\"; listen(\"tauri://update-available\", function (res)\n{ console.log(\"New version available: \", res); }); ``` #### Emit Install and\nDownload You need to emit this event to initialize the download and listen to\nthe [install progress](#listen-install-progress). Event:\n`tauri://update-install` #### Rust ```rust\nwindow.emit(\"tauri://update-install\".to_string(), None); ``` #### Javascript\n```js import { emit } from \"@tauri-apps/api/event\";\nemit(\"tauri://update-install\"); ``` #### Listen Install Progress Event:\n`tauri://update-status` Emitted data: ```none status [ERROR/PENDING/DONE] error\nString/null ``` PENDING is emitted when the download is started and DONE when\nthe install is complete. You can then ask to restart the application. ERROR is\nemitted when there is an error with the updater. We suggest listening to this\nevent even if the dialog is enabled. #### Rust ```rust\nwindow.listen(\"tauri://update-status\".to_string(), move |msg| { println!(\"New\nstatus: {:?}\", msg); }) ``` #### Javascript ```js import { listen } from\n\"@tauri-apps/api/event\"; listen(\"tauri://update-status\", function (res) {\nconsole.log(\"New status: \", res); }); ``` ## Server Support Your server should\ndetermine whether an update is required based on the [Update\nRequest](#update-requests) your client issues. If an update is required, your\nserver should respond with a status code of [200 OK] and include the [update\nJSON](#update-server-json-format) in the body. If no update is required your\nserver must respond with a status code of [204 No Content]. ### Update Server\nJSON Format When an update is available, Tauri expects the following schema in\nresponse to the update request provided: ```json { \"url\":\n\"https://mycompany.example.com/myapp/releases/myrelease.tar.gz\", \"version\":\n\"0.0.1\", \"notes\": \"Theses are some release notes\", \"pub_date\":\n\"2020-09-18T12:29:53+01:00\", \"signature\": \"\" } ``` The only required keys are\n\"url\" and \"version\"; the others are optional. \"pub_date\" if present must be\nformatted according to ISO 8601. \"signature\" if present, must be a valid\nsignature generated with Tauri CLI. See [Signing updates](#signing-updates). ###\nUpdate File JSON Format The alternate update technique uses a plain JSON file,\nstoring your update metadata on S3, gist, or another static file store. Tauri\nchecks against the name/version field, and if the version is smaller than the\ncurrent one and the platform is available, it triggers an update. The format of\nthis file is detailed below: ```json { \"name\":\"v1.0.0\", \"notes\":\"Test version\",\n\"pub_date\":\"2020-06-22T19:25:57Z\", \"platforms\": { \"darwin\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.app.tar.gz\"\n}, \"linux\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.AppImage.tar.gz\"\n}, \"win64\": { \"signature\":\"\",\n\"url\":\"https://github.com/lemarier/tauri-test/releases/download/v1.0.0/app.x64.msi.zip\"\n} } } ``` ## Bundler (Artifacts) The Tauri bundler automatically generates\nupdate artifacts if the updater is enabled in `tauri.conf.json` Your update\nartifacts are automatically signed if the bundler can locate your private and\npublic key. The signature can be found in the `sig` file. The signature can be\nuploaded to GitHub safely or made public if your private key is secure. You can\nsee how it's [bundled with the CI][Artifacts Updater Workflow] and a [sample\ntauri.conf.json]. ### macOS On macOS, we create a .tar.gz from the whole\napplication. (.app) ```none target/release/bundle └── osx └── app.app └──\napp.app.tar.gz (update bundle) └── app.app.tar.gz.sig (if signature enabled) ```\n### Windows On Windows, we create a .zip from the MSI; when downloaded and\nvalidated, we run the MSI install. ```none target/release └── app.x64.msi └──\napp.x64.msi.zip (update bundle) └── app.x64.msi.zip.sig (if signature enabled)\n``` ### Linux On Linux, we create a .tar.gz from the AppImage. ```none\ntarget/release/bundle └── appimage └── app.AppImage └── app.AppImage.tar.gz\n(update bundle) └── app.AppImage.tar.gz.sig (if signature enabled) ``` ##\nSigning updates We offer a built-in signature to ensure your update is safe to\nbe installed. To sign your updates, you need two things. The *Public-key*\n(pubkey) should be added inside your `tauri.conf.json` to validate the update\narchive before installing. The *Private key* (privkey) is used to sign your\nupdate and should NEVER be shared with anyone. Also, if you lost this key,\nyou'll NOT be able to publish a new update to the current user base (if pubkey\nis set in tauri.conf.json). It's crucial to save it in a safe place, and you can\nalways access it. To generate your keys, you need to use the Tauri cli. ```bash\ntauri sign -g -w ~/.tauri/myapp.key ``` You have multiple options available ```\nTauri updates signer. USAGE: tauri sign [FLAGS] [OPTIONS] FLAGS: --force\nOverwrite private key even if it exists on the specified path -g, --generate\nGenerate keypair to sign files -h, --help Prints help information --no-password\nSet empty password for your private key -V, --version Prints version information\nOPTIONS: -p, --password Set private key password when signing -k, --private-key\nLoad the private key from a string -f, --private-key-path Load the private key\nfrom a file --sign-file Sign the specified file -w, --write-keys Write private\nkey to a file ``` *** Environment variables used to sign with the Tauri\n`bundler`: If they are set, and `tauri.conf.json` exposes the public key, the\nbundler automatically generates and signs the updater artifacts.\n`TAURI_PRIVATE_KEY` Path or String of your private key `TAURI_KEY_PASSWORD` Your\nprivate key password (optional) [200 OK]:\nhttp://tools.ietf.org/html/rfc2616#section-10.2.1 [204 No Content]:\nhttp://tools.ietf.org/html/rfc2616#section-10.2.5 [Artifacts Updater Workflow]:\nhttps://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/.github/workflows/artifacts-updater.yml#L44\n[sample tauri.conf.json]:\nhttps://github.com/tauri-apps/tauri/blob/5b6c7bb6ee3661f5a42917ce04a89d94f905c949/examples/updater/src-tauri/tauri.conf.json#L52","url":"https://tauri.studio/docs/distribution/updater"},{"id":"prose_docs_distribution_windows_md","title":"Windows Application Distribution","area":"distribution","section":"distribution","headings":["Using a fixed version of the Webview2 Runtime","Customizing the Windows Installer","i18n","Code signing"],"subHeadings":["Replacing the installer code with a custom WiX file","Extending the installer with WiX fragments"],"code":["json","xml"],"text":"# Windows Application Distribution Tauri applications for Windows are\ndistributed either with a Microsoft Installer (`.msi` files). The Tauri CLI\nautomatically bundles your application code in this format, providing options to\ncode sign your application. This guide provides information on available\ncustomizations for the installer. ## Using a fixed version of the Webview2\nRuntime By default, the Tauri installer downloads and installs the Webview2\nRuntime if it is not already installed (on Windows 11, the runtime is\ndistributed as part of the operating system). :::note You can remove the\nWebview2 Runtime download check from the installer by setting\n[tauri.bundle.windows.wix.skipWebviewInstall] to `true`. Your application WON'T\nwork if the user does not have the runtime installed. ::: Using the runtime\nprovided by the system is great for security as the webview vulnerability\npatches are managed by Windows. If you want to control the Webview2 distribution\non each of your applications, either to manage the release patches yourself or\ndistribute applications on environments where internet connection might not be\navailable. In that case, Tauri can bundle the runtime files for you. - Download\nthe Webview2 fixed version runtime on the [official website], a `.cab` file for\nthe selected architecture. In this example, the downloaded filename is\nMicrosoft.WebView2.FixedVersionRuntime.98.0.1108.50.x64.cab - Extract the file\nto the core folder: `Expand\n.\\Microsoft.WebView2.FixedVersionRuntime.98.0.1108.50.x64.cab -F:* ./src-tauri`\n- Configure the Webview2 runtime path on `tauri.conf.json`: ```json { \"tauri\": {\n\"bundle\": { \"windows\": { \"webviewFixedRuntimePath\":\n\"./Microsoft.WebView2.FixedVersionRuntime.98.0.1108.50.x64/\" } } } } ``` - Run\n`tauri build` to produce the Windows Installer with the fixed Webview2 runtime.\n:::caution Distributing a fixed Webview2 Runtime version increases the Windows\nInstaller by around 150MB. ::: ## Customizing the Windows Installer The Windows\nInstaller package is built using the [WiX Toolset v3]. Currently, you can change\nit by using a custom WiX source code (an XML file with a `.wxs` file extension)\nor through WiX fragments. ### Replacing the installer code with a custom WiX\nfile The Windows Installer XML defined by Tauri is configured to work for the\ncommon use case of simple webview-based applications; you can find it [here]. It\nuses [handlebars] so the Tauri CLI can brand your installer according to your\n`tauri.conf.json` definition. If you need a completely different installer, a\ncustom template file can be configured on [tauri.bundle.windows.wix.template].\n### Extending the installer with WiX fragments A [WiX fragment] is a container\nwhere you can configure almost everything offered by WiX. In this example, we\nwill define a fragment that writes two registry entries: ```xml ``` Save the\nfragment file with the `.wxs` extension somewhere in your project and reference\nit on `tauri.conf.json`: ```json { \"tauri\": { \"bundle\": { \"windows\": { \"wix\": {\n\"fragmentPaths\": [\"./path/to/registry.wxs\"], \"componentRefs\":\n[\"MyFragmentRegistryEntries\"] } } } } } ``` Note that `ComponentGroup`,\n`Component`, `FeatureGroup`, `Feature` and `Merge` element ids must be\nreferenced on the `wix` object of `tauri.conf.json` on the `componentGroupRefs`,\n`componentRefs`, `featureGroupRefs`, `featureRefs` and `mergeRefs` respectively\nin order to be included on the installer. ## i18n The Windows Installer is built\nusing the `en-US` language by default. i18n (shorthand for internationalization)\ncan be configured using the [tauri.bundle.windows.wix.language] property,\ndefining the languages Tauri should build an installer against. You can find the\nlanguage names to use on the Language-Culture column [here][1]. - Compiling an\ninstaller for a single language To create a single installer targeting a\nspecific language, set the `language` value to a string: ```json { \"tauri\": {\n\"bundle\": { \"windows\": { \"wix\": { \"language\": \"fr-FR\" } } } } } ``` - Compiling\nan installer for each language in a list To compile an installer targeting a\nlist of languages, use an array. A specific installer for each language will be\ncreated, with the language key as a suffix: ```json { \"tauri\": { \"bundle\": {\n\"windows\": { \"wix\": { \"language\": [\"en-US\", \"pt-BR\", \"fr-FR\"] } } } } } ``` -\nConfiguring the installer for each language A configuration object can be\ndefined for each language to configure localization strings: ```json { \"tauri\":\n{ \"bundle\": { \"windows\": { \"wix\": { \"language\": { \"en-US\": null, \"pt-BR\": {\n\"localePath\": \"./wix/locales/pt-BR.wxl\" } } } } } } } ``` The `localePath`\nproperty defines the path to a language file, a XML configuring the language\nculture: ```xml Launch MyApplicationName A newer version of MyApplicationName is\nalready installed. Add the install location of the MyApplicationName executable\nto the PATH system environment variable. This allows the MyApplicationName\nexecutable to be called from any location. Installs MyApplicationName. ```\n:::note The `WixLocalization` element's `Culture` field must match the\nconfigured language. ::: Currently Tauri references the following locale\nstrings: `LaunchApp`, `DowngradeErrorMessage`, `PathEnvVarFeature` and\n`InstallAppFeature`. You can define your own strings and reference them on your\ncustom template or fragments with `\"!(loc.TheStringId)\"`. See the [WiX\nlocalization documentation] for more information. ## Code signing See the [Code\nsigning guide]. [tauri.bundle.windows.wix.skipWebviewInstall]:\n/docs/api/config/#tauri.bundle.windows.wix.skipWebviewInstall [official\nwebsite]:\nhttps://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section\n[WiX Toolset v3]: https://wixtoolset.org/documentation/manual/v3/ [here]:\nhttps://github.com/tauri-apps/tauri/blob/dev/tooling/bundler/src/bundle/windows/templates/main.wxs\n[handlebars]: https://docs.rs/handlebars/latest/handlebars/\n[tauri.bundle.windows.wix.template]:\n/docs/api/config/#tauri.bundle.windows.wix.template [WiX fragment]:\nhttps://wixtoolset.org/documentation/manual/v3/xsd/wix/fragment.html\n[tauri.bundle.windows.wix.language]:\n/docs/api/config/#tauri.bundle.windows.wix.language [1]:\nhttps://docs.microsoft.com/en-us/windows/win32/msi/localizing-the-error-and-actiontext-tables\n[WiX localization documentation]:\nhttps://wixtoolset.org/documentation/manual/v3/howtos/ui_and_localization/make_installer_localizable.html\n[Code signing guide]: ./sign-windows.md","url":"https://tauri.studio/docs/distribution/windows"},{"id":"prose_docs_getting_started_beginning_tutorial_md","title":"Your First Tauri App","area":"getting-started","section":"getting-started","headings":["Vue CLI Plugin Tauri"],"subHeadings":["1","1","2","3","Recipes"],"code":["bash","sh",null],"text":"import Command from '@theme/Command' import Link from '@docusaurus/Link' # Your\nFirst Tauri App :::caution You must have completed all the steps required for\nsetting up the development environment on your machine. Please see the [setup\npage for your operating system][Prerequisites] if you haven't done this yet. :::\nThere are two ways to integrate with Tauri depending on your needs: - [Start a\nnew Tauri project](#1-start-a-new-tauri-project) - Or [add Tauri to existing\nproject](#1-add-tauri-to-existing-project) ### 1. Start a New Tauri Project\n```bash yarn create tauri-app #OR npx create-tauri-app ``` Follow the\ninstructions and choose the web front-end framework you prefer.\n`create-tauri-app` creates a template project depending on your inputs. You can\ngo straight to [check `tauri\ninfo`](#3-check-tauri-info-to-make-sure-everything-is-set-up-properly) after\nthis. ### 1. Add Tauri to Existing Project: The Tauri CLI tool helps you build\nyour project, so install it first. You can install Tauri CLI [using\n`Node.js`](#install-tauri-cli-package-as-a-dev-dependency) or [using\n`Rust`](#alternatively-install-tauri-cli-as-a-cargo-subcommand) #### Install\nTauri CLI package as a dev dependency: ```bash cd project-folder # Not required\nif you already have a package.json: # yarn init # OR # npm init yarn add -D\n@tauri-apps/cli # OR npm install -D @tauri-apps/cli ``` :::note You can install\nTauri as both a local and a global dependency, but we recommend installing it\nlocally. ::: If you decide to use Tauri as a local package with npm (not yarn),\nyou need to add a custom script to your package.json: ```js title=package.json {\n// This content is just a sample \"scripts\": { \"tauri\": \"tauri\" } } ``` ####\nAlternatively, install Tauri CLI as a cargo subcommand: The following command\ninstalls `tauri-cli` as a Cargo subcommand on the cargo binary folder (by\ndefault on `$HOME/.cargo/bin`): ```bash cargo install tauri-cli --locked\n--version ^1.0.0-rc ``` For more installation options, see [`cargo install`].\n#### Install Tauri API Package as a Dependency (optional): The `@tauri-apps/api`\npackage is recommended for projects using ES modules or modern build tools such\nas Webpack or Vite. It is the most secure way to access the Tauri APIs. ```bash\nyarn add @tauri-apps/api # OR npm install @tauri-apps/api ``` ### 2. Initialize\nTauri in Your App This command places a new folder in your current working\ndirectory, `src-tauri`. ```sh └── src-tauri ├── .gitignore ├── Cargo.toml ├──\nrustfmt.toml ├── tauri.conf.json ├── icons │ ├── 128x128.png │ ├──\n128x128@2x.png │ ├── 32x32.png │ ├── Square107x107Logo.png │ ├──\nSquare142x142Logo.png │ ├── Square150x150Logo.png │ ├── Square284x284Logo.png │\n├── Square30x30Logo.png │ ├── Square310x310Logo.png │ ├── Square44x44Logo.png │\n├── Square71x71Logo.png │ ├── Square89x89Logo.png │ ├── StoreLogo.png │ ├──\nicon.icns │ ├── icon.ico │ └── icon.png └── src ├── build.rs ├── cmd.rs └──\nmain.rs ``` ### 3. Check `tauri info` to Make Sure Everything Is Set up\nProperly: Which should return something like: ``` Operating System -\nDarwin(16.7.0) - darwin/x64 Node.js environment Node.js - 12.16.3\n@tauri-apps/cli - 1.0.0-rc.0 @tauri-apps/api - 1.0.0-rc.0 Global packages npm -\n6.14.15 pnpm - Not installed yarn - 1.22.17 Rust environment rustup - 1.24.3\nrustc - 1.58.1 cargo - 1.58.0 toolchain - stable-x86_64-unknown-linux-gnu App\ndirectory structure /node_modules /src-tauri /src /public App tauri.rs -\n1.0.0-rc.0 build-type - bundle CSP - default-src 'self' distDir - ../public\ndevPath - ../public framework - Svelte bundler - Rollup ``` This information can\nbe beneficial when triaging problems. ### Recipes We've also defined prebuilt\nconfigurations called \"Recipes\". They may help you to customize Tauri to fit\nyour needs. [See more about recipes][Recipes]. ## Vue CLI Plugin Tauri If you\nare using Vue CLI, it is recommended to use the official [Vue CLI plugin].\n[Prerequisites]: ./prerequisites.md [`cargo install`]:\nhttps://doc.rust-lang.org/cargo/commands/cargo-install.html#description\n[Recipes]: ../architecture/recipes/about-recipes.md [Vue CLI plugin]:\nhttps://github.com/tauri-apps/vue-cli-plugin-tauri","url":"https://tauri.studio/docs/getting-started/beginning-tutorial"},{"id":"prose_docs_getting_started_prerequisites_md","title":"Prerequisites","area":"getting-started","section":"getting-started","headings":[],"subHeadings":[],"code":[],"text":"import OSList from '@theme/OSList' # Prerequisites - Rust - Node (optional) - OS\nspecific build tooling, eg. `build-essential`, `xcode-select` or `C++ build\ntools` For more information on platform-specific build tooling, see these guides\nto get started. After that, you'll be ready to [make your first Tauri\napp][Beginning Tutorial]! [Beginning Tutorial]: ./beginning-tutorial.md","url":"https://tauri.studio/docs/getting-started/prerequisites"},{"id":"prose_docs_getting_started_setting_up_linux_md","title":"Setting Up Linux","area":"getting-started","section":"getting-started","headings":["1","2","3","4","Continue"],"subHeadings":["Optional dependencies","Node","Optional Node","WSL Version 1","WSL Version 2"],"code":["sh","bash"],"text":"import Icon from '@theme/Icon' import { Intro } from '@theme/SetupDocs' import\nTabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; # Setting Up\nLinux ## 1. System Dependencies  ```sh $ sudo apt update && sudo apt install\nlibwebkit2gtk-4.0-dev \\ build-essential \\ curl \\ wget \\ libssl-dev \\\nlibgtk-3-dev \\ libappindicator3-dev \\ patchelf \\ librsvg2-dev ``` ```sh $ sudo\npacman -Syu && sudo pacman -S --needed \\ webkit2gtk \\ base-devel \\ curl \\ wget \\\nopenssl \\ appmenu-gtk-module \\ gtk3 \\ libappindicator-gtk3 \\ patchelf \\ librsvg\n\\ libvips ``` ```sh $ sudo dnf check-update && sudo dnf install\nwebkit2gtk3-devel.x86_64 \\ openssl-devel \\ curl \\ wget \\ libappindicator-gtk3 \\\npatchelf \\ librsvg2-devel \\ && sudo dnf group install \"C Development Tools and\nLibraries\" ``` ### Optional dependencies: - `libappindicator`: needed to use the\nsystem tray feature. - `patchelf` and `librsvg`: needed to bundle `AppImage`. ##\n2. Node.js Runtime and Package Manager  ### Node.js (npm included) We recommend\nusing nvm to manage your Node.js runtime. It allows you to switch versions and\nupdate Node.js easily. ```sh $ curl -o-\nhttps://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash ```\n:::note We have audited this bash script, and it does what it says it is\nsupposed to do. Nevertheless, before blindly curl-bashing a script, it is always\nwise to look at it first. Here is the file as a mere [download link][[nvm\ninstall.sh]]. ::: Once nvm is installed, close and reopen your terminal, then\ninstall the latest version of Node.js and npm: ```sh $ nvm install node\n--latest-npm $ nvm use node ``` If you have any problems with nvm, please\nconsult their [project readme][nvm]. ### Optional Node.js Package Manager You\nmay want to use an alternative to npm: - [Yarn@v1] - Used by the Tauri team for\nv1 - [pnpm] - Alternative package manager focusing on decreasing disk space and\ninstallation time ## 3. Rustc and Cargo Package Manager  The following command\ninstalls [rustup], the official installer for [Rust]. ```bash $ curl --proto\n'=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh ``` :::note We have audited\nthis bash script, and it does what it says it is supposed to do. Nevertheless,\nbefore blindly curl-bashing a script, it is always wise to look at it first.\nHere is the file as a mere [download link][rustup.sh]. ::: To make sure that\nRust has been installed successfully, run the following command: ```sh $ rustc\n--version latest update on 2019-12-19, rust version 1.40.0 ``` You may need to\nrestart your terminal if the command does not work. ## 4. For Windows Subsystem\nfor Linux (WSL) Users  To run a graphical application with WSL, you need to\ndownload **one** of these X servers: Xming, Cygwin X, and vcXsrv. Since vcXsrv\nhas been used internally, it's the one we recommend installing. ### WSL Version\n1 Open the X server and then run `export DISPLAY=:0` in the terminal. You should\nnow be able to run any graphical application via the terminal. ### WSL Version 2\nYou'll need to run a command that is slightly more complex than WSL 1: `export\nDISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0` and you\nneed to add `-ac` to the X server as an argument. Note: if for some reason this\ncommand doesn't work you can use an alternative command such as: `export\nDISPLAY=$(cat /etc/resolv.conf | grep nameserver | sed 's/.* //g'):0` or you can\nmanually find the Address using `cat /etc/resolve.conf | grep nameserver`.\n:::note Don't forget that you'll have to use the \"export\" command anytime you\nwant to use a graphical application for each newly opened terminal. You can\ndownload some examples to try with `sudo apt-get install x11-apps`. xeyes is\nalways a good one. It can be handy when troubleshooting WSL issues. ::: ##\nContinue Now that you have set up the Linux-specific dependencies for Tauri,\nlearn how to [add Tauri to your project][Beginning Tutorial]. [nvm]:\nhttps://github.com/nvm-sh/nvm [nvm install.sh]:\nhttps://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh [Beginning\nTutorial]: ./beginning-tutorial.md [Yarn@v1]:\nhttps://classic.yarnpkg.com/en/docs/getting-started [pnpm]:\nhttps://pnpm.js.org/en/installation [rustup]: https://rustup.rs/ [Rust]:\nhttps://www.rust-lang.org/ [rustup.sh]: https://sh.rustup.rs/","url":"https://tauri.studio/docs/getting-started/setting-up-linux"},{"id":"prose_docs_getting_started_setting_up_macos_md","title":"Setting Up macOS","area":"getting-started","section":"getting-started","headings":["1","2","3","Continue"],"subHeadings":["Node","Optional Node"],"code":["sh",null],"text":"import { Intro } from '@theme/SetupDocs' import Icon from '@theme/Icon' #\nSetting Up macOS ## 1. System Dependencies  Make sure you have `xcode`\ninstalled. ```sh $ xcode-select --install ``` ## 2. Node.js Runtime and Package\nManager  ### Node.js (npm included) We recommend using nvm to manage your\nNode.js runtime. It allows you to switch versions and update Node.js easily.\n```sh $ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh\n| bash ``` :::note We have audited this bash script, and it does what it says it\nis supposed to do. Nevertheless, before blindly curl-bashing a script, it is\nalways wise to look at it first. Here is the file as a mere [download link][nvm\ninstall.sh]. ::: Once nvm is installed, close and reopen your terminal, then\ninstall the latest version of Node.js and npm: ```sh $ nvm install node\n--latest-npm $ nvm use node ``` If you have any problems with nvm, please\nconsult their [project readme][nvm]. ### Optional Node.js Package Manager You\nmay want to use an alternative to npm: - [Yarn@v1] - Used by the Tauri team for\nv1 - [pnpm] - Alternative package manager focusing on decreasing disk space and\ninstallation time ## 3. Rustc and Cargo Package Manager  The following command\nwill install [rustup], the official installer for [Rust]. ``` $ curl --proto\n'=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh ``` :::note We have audited\nthis bash script, and it does what it says it is supposed to do. Nevertheless,\nbefore blindly curl-bashing a script, it is always wise to look at it first.\nHere is the file as a mere [download link][rustup.sh]. ::: To make sure that\nRust has been installed successfully, run the following command: ```sh $ rustc\n--version latest update on 2019-12-19, rust version 1.40.0 ``` You may need to\nrestart your terminal if the command does not work. ## Continue Now that you\nhave set up the macOS-specific dependencies for Tauri, learn how to [add Tauri\nto your project][Beginning Tutorial]. [nvm]: https://github.com/nvm-sh/nvm [nvm\ninstall.sh]: https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh\n[Beginning Tutorial]: ./beginning-tutorial.md [Yarn@v1]:\nhttps://classic.yarnpkg.com/en/docs/getting-started [pnpm]:\nhttps://pnpm.js.org/en/installation [rustup]: https://rustup.rs/ [Rust]:\nhttps://www.rust-lang.org/ [rustup.sh]: https://sh.rustup.rs/","url":"https://tauri.studio/docs/getting-started/setting-up-macos"},{"id":"prose_docs_getting_started_setting_up_windows_md","title":"Setting Up Windows","area":"getting-started","section":"getting-started","headings":["1","2","3","4","Continue"],"subHeadings":["Node","Optional Node"],"code":["powershell"],"text":"import Icon from '@theme/Icon' import { Intro } from '@theme/SetupDocs' #\nSetting Up Windows :::note For those using the Windows Subsystem for Linux\n(WSL), please refer to our [Linux specific instructions] instead. ::: ## 1.\nSystem Dependencies  You'll need to install Microsoft Visual Studio C++ build\ntools. [Download the installer here][Microsoft Visual Studio C++ build tools],\nand then run it. When it asks you what packages you would like to install,\nselect C++ Build Tools and make sure the Windows SDK is selected. :::note This\nis a big download (over 1GB) and takes the most time, so grab a snack or coffee.\n::: :::caution You may need to uninstall the 2017 version of the build tools if\nyou have them. There are reports of Tauri not working with both the 2017 and\n2019 versions installed. ::: ## 2. Node.js Runtime and Package Manager  ###\nNode.js (npm included) We recommend using [nvm-windows] to manage your Node.js\nruntime. It allows you to switch versions and update Node.js easily. Then run\nthe following from an Administrative PowerShell and press Y when prompted:\n```powershell # BE SURE YOU ARE IN AN ADMINISTRATIVE PowerShell! nvm install\nlatest nvm use {{latest}} # Replace with your latest downloaded version ``` This\ninstalls the most recent version of Node.js with npm. ### Optional Node.js\nPackage Manager You may want to use an alternative to npm: - [Yarn@v1] - Used by\nthe Tauri team for v1 - [pnpm] - Alternative package manager focusing on\ndecreasing disk space and installation time ## 3. Rustc and Cargo Package\nManager  Now you need to install [Rust]. The easiest way to do this is to use\n[rustup], the official installer. - [64-bit download link][rustup x86_64] -\n[32-bit download link][rustup i686] Download and install the proper variant for\nyour computer's architecture. ## 4. Install WebView2 :::tip WebView2 is\npre-installed in Windows 11. ::: Finally, you need to install WebView2. The best\nway to do this is to download and run the Evergreen Bootstrapper from [this\npage](https://developer.microsoft.com/en-us/microsoft-edge/webview2/#download-section).\n:::note If you have problems of any kind after following these instructions, we\nrecommend that you reboot your computer before developing a Tauri project to\nensure that everything works as expected. ::: ## Continue Now that you have set\nup the Windows-specific dependencies for Tauri learn how to [add Tauri to your\nproject][Beginning Tutorial]. [nvm-windows]:\nhttps://github.com/coreybutler/nvm-windows#installation--upgrades [Beginning\nTutorial]: ./beginning-tutorial.md [Yarn@v1]:\nhttps://classic.yarnpkg.com/en/docs/getting-started [pnpm]:\nhttps://pnpm.js.org/en/installation [rustup x86_64]:\nhttps://win.rustup.rs/x86_64 [rustup i686]: https://win.rustup.rs/i686 [Rust]:\nhttps://www.rust-lang.org/ [rustup]: https://rustup.rs/ [Microsoft Visual Studio\nC++ build tools]: https://visualstudio.microsoft.com/visual-cpp-build-tools/\n[Linux specific instructions]: /docs/getting-started/setting-up-linux","url":"https://tauri.studio/docs/getting-started/setting-up-windows"},{"id":"prose_docs_guides_cli_md","title":"Making Your Own CLI","area":"guides","section":"guides","headings":["Base Configuration","Adding Arguments","Subcommands","Reading the matches","Complete documentation"],"subHeadings":["Positional Arguments","Named Arguments","Flag Arguments","Rust","JavaScript"],"code":["rust","js"],"text":"# Making Your Own CLI Tauri enables your app to have a CLI through [clap], a\nrobust command line argument parser. With a simple CLI definition in your\n`tauri.conf.json` file, you can define your interface and read its argument\nmatches map on JavaScript and/or Rust. ## Base Configuration Under\n`tauri.conf.json`, you have the following structure to configure the interface:\n```js title=src-tauri/tauri.conf.json { \"tauri\": { \"cli\": { \"description\": \"\",\n// command description that's shown on help \"longDescription\": \"\", // command\nlong description that's shown on help \"beforeHelp\": \"\", // content to show\nbefore the help text \"afterHelp\": \"\", // content to show after the help text\n\"args\": [], // list of arguments of the command, we'll explain it later\n\"subcommands\": { \"subcommand-name\": { // configures a subcommand that is\naccessible // with `$ ./app subcommand-name --arg1 --arg2 --etc` //\nconfiguration as above, with \"description\", \"args\", etc. } } } } } ``` :::note\nAll JSON configurations here are just samples, many other fields have been\nomitted for the sake of clarity. ::: ## Adding Arguments The `args` array\nrepresents the list of arguments accepted by its command or subcommand. You can\nfind more details about the way to configure them [here][Tauri config]. ###\nPositional Arguments A positional argument is identified by its position in the\nlist of arguments. With the following configuration: ```json\ntitle=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ { \"name\": \"source\",\n\"index\": 1, \"takesValue\": true }, { \"name\": \"destination\", \"index\": 2,\n\"takesValue\": true } ] } ``` Users can run your app as `$ ./app tauri.txt\ndest.txt` and the arg matches map will define `source` as `\"tauri.txt\"` and\n`destination` as `\"dest.txt\"`. ### Named Arguments A named argument is a (key,\nvalue) pair where the key identifies the value. With the following\nconfiguration: ```json title=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ {\n\"name\": \"type\", \"short\": \"t\", \"takesValue\": true, \"multiple\": true,\n\"possibleValues\": [\"foo\", \"bar\"] } ] } ``` Users can run your app as `$ ./app\n--type foo bar`, `$ ./app -t foo -t bar` or `$ ./app --type=foo,bar` and the arg\nmatches map will define `type` as `[\"foo\", \"bar\"]`. ### Flag Arguments A flag\nargument is a standalone key whose presence or absence provides information to\nyour application. With the following configuration: ```js\ntitle=src-tauri/tauri.conf.json:tauri.cli { \"args\": [ \"name\": \"verbose\",\n\"short\": \"v\", \"multipleOccurrences\": true ] } ``` Users can run your app as `$\n./app -v -v -v`, `$ ./app --verbose --verbose --verbose` or `$ ./app -vvv` and\nthe arg matches map will define `verbose` as `true`, with `occurrences = 3`. ##\nSubcommands Some CLI applications has additional interfaces as subcommands. For\ninstance, the `git` CLI has `git branch`, `git commit` and `git push`. You can\ndefine additional nested interfaces with the `subcommands` array: ```js\ntitle=src-tauri/tauri.conf.json:tauri { \"cli\": { ... \"subcommands\": { \"branch\":\n{ \"args\": [] }, \"push\": { \"args\": [] } } } } ``` Its configuration is the same\nas the root application configuration, with the `description`,\n`longDescription`, `args`, etc. ## Reading the matches ### Rust ```rust use\ntauri::api::cli::get_matches; fn main() { let context =\ntauri::generate_context!(); let cli_config =\ncontext.config().tauri.cli.clone().unwrap(); match get_matches(&cli_config) { //\n`matches` here is a Struct with { args, subcommand }. // `args` is `HashMap`\nwhere `ArgData` is a struct with { value, occurances }. // `subcommand` is\n`Option>` where `SubcommandMatches` is a struct with { name, matches }.\nOk(matches) => { println!(\"{:?}\", matches) } Err(_) => {} };\ntauri::Builder::default() .run(context) .expect(\"error while running tauri\napplication\"); } ``` ### JavaScript ```js import { getMatches } from\n'@tauri-apps/api/cli' getMatches().then((matches) => { // do something with the\n{ args, subcommand } matches }) ``` ## Complete documentation You can find more\nabout the CLI configuration [here][Tauri config]. [clap]:\nhttps://github.com/clap-rs/clap [Tauri config]: /docs/api/config#tauri","url":"https://tauri.studio/docs/guides/cli"},{"id":"prose_docs_guides_command_md","title":"Creating Rust Commands","area":"guides","section":"guides","headings":["Basic Example","Passing Arguments","Returning Data","Error Handling","Async Commands","Accessing the Window in Commands","Accessing an AppHandle in Commands","Accessing managed state","Creating Multiple Commands","Complete Example"],"subHeadings":[],"code":["rust","js"],"text":"# Creating Rust Commands Tauri provides a simple yet powerful \"command\" system\nfor calling Rust functions from your web app. Commands can accept arguments and\nreturn values. They can also return errors and be `async`. ## Basic Example\nCommands are defined in your `src-tauri/src/main.rs` file. To create a command,\njust add a function and annotate it with `#[tauri::command]`: ```rust\n#[tauri::command] fn my_custom_command() { println!(\"I was invoked from JS!\"); }\n``` You will have to provide a list of your commands to the builder function\nlike so: ```rust // Also in main.rs fn main() { tauri::Builder::default() //\nThis is where you pass in your commands\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ``` Now, you\ncan invoke the command from your JS code: ```js // With the Tauri API npm\npackage: import { invoke } from '@tauri-apps/api/tauri' // With the Tauri global\nscript, enabled when `tauri.conf.json > build > withGlobalTauri` is set to true:\nconst invoke = window.__TAURI__.invoke // Invoke the command\ninvoke('my_custom_command') ``` ## Passing Arguments Your command handlers can\ntake arguments: ```rust #[tauri::command] fn my_custom_command(invoke_message:\nString) { println!(\"I was invoked from JS, with this message: {}\",\ninvoke_message); } ``` Arguments should be passed as a JSON object with\ncamelCase keys: ```js invoke('my_custom_command', { invokeMessage: 'Hello!' })\n``` Arguments can be of any type, as long as they implement\n[`serde::Deserialize`]. ## Returning Data Command handlers can return data as\nwell: ```rust #[tauri::command] fn my_custom_command() -> String { \"Hello from\nRust!\".into() } ``` The `invoke` function returns a promise that resolves with\nthe returned value: ```js invoke('my_custom_command').then((message) =>\nconsole.log(message)) ``` Returned data can be of any type, as long as it\nimplements [`serde::Serialize`]. ## Error Handling If your handler could fail\nand needs to be able to return an error, have the function return a `Result`:\n```rust #[tauri::command] fn my_custom_command() -> Result { // If something\nfails Err(\"This failed!\".into()) // If it worked Ok(\"This worked!\".into()) } ```\nIf the command returns an error, the promise will reject, otherwise it resolves:\n```js invoke('my_custom_command') .then((message) => console.log(message))\n.catch((error) => console.error(error)) ``` ## Async Commands :::note Async\ncommands are executed on a separate thread using [`async_runtime::spawn`].\nCommands without the *async* keyword are executed on the main thread, unless\ndefined with *#[tauri::command(async)]*. ::: If your command needs to run\nasynchronously, simply declare it as `async`: ```rust #[tauri::command] async fn\nmy_custom_command() { // Call another async function and wait for it to finish\nlet result = some_async_function().await; println!(\"Result: {}\", result); } ```\nSince invoking the command from JS already returns a promise, it works just like\nany other command: ```js invoke('my_custom_command').then(() =>\nconsole.log('Completed!')) ``` ## Accessing the Window in Commands Commands can\naccess the `Window` instance that invoked the message: ```rust #[tauri::command]\nasync fn my_custom_command(window: tauri::Window) { println!(\"Window: {}\",\nwindow.label()); } ``` ## Accessing an AppHandle in Commands Commands can access\nan `AppHandle` instance: ```rust #[tauri::command] async fn\nmy_custom_command(app_handle: tauri::AppHandle) { let app_dir =\napp_handle.path_resolver().app_dir(); use tauri::GlobalShortcutManager;\napp_handle.global_shortcut_manager().register(\"CTRL + U\", move || {}); } ``` ##\nAccessing managed state Tauri can manage state using the `manage` function on\n`tauri::Builder`. The state can be accessed on a command using `tauri::State`:\n```rust struct MyState(String); #[tauri::command] fn my_custom_command(state:\ntauri::State) { assert_eq!(state.0 == \"some state value\", true); } fn main() {\ntauri::Builder::default() .manage(MyState(\"some state value\".into()))\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ## Creating Multiple Commands The\n`tauri::generate_handler!` macro takes an array of commands. To register\nmultiple commands, you cannot call invoke_handler multiple times. Only the last\ncall will be used. You must pass each command to a single call of\n`tauri::generate_handler!`. ```rust #[tauri::command] fn cmd_a() -> String {\n\"Command a\" } #[tauri::command] fn cmd_b() -> String { \"Command b\" } fn main() {\ntauri::Builder::default() .invoke_handler(tauri::generate_handler![cmd_a,\ncmd_b]) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ## Complete Example Any or all of the above features can be\ncombined: ```rust title=main.rs // Definition in main.rs struct Database;\n#[derive(serde::Serialize)] struct CustomResponse { message: String, other_val:\nusize, } async fn some_other_function() -> Option { Some(\"response\".into()) }\n#[tauri::command] async fn my_custom_command( window: tauri::Window, number:\nusize, database: tauri::State<'_, Database>, ) -> Result { println!(\"Called from\n{}\", window.label()); let result: Option = some_other_function().await; if let\nSome(message) = result { Ok(CustomResponse { message, other_val: 42 + number, })\n} else { Err(\"No result\".into()) } } fn main() { tauri::Builder::default()\n.manage(Database {})\n.invoke_handler(tauri::generate_handler![my_custom_command])\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ```js // Invocation from JS invoke('my_custom_command', {\nnumber: 42, }) .then((res) => console.log(`Message: ${res.message}, Other Val:\n${res.other_val}`) ) .catch((e) => console.error(e)) ```\n[`async_runtime::spawn`]:\nhttps://docs.rs/tauri/1.0.0-rc.0/tauri/async_runtime/fn.spawn.html\n[`serde::Serialize`]: https://docs.serde.rs/serde/trait.Serialize.html\n[`serde::Deserialize`]: https://docs.serde.rs/serde/trait.Deserialize.html","url":"https://tauri.studio/docs/guides/command"},{"id":"prose_docs_guides_events_md","title":"Events","area":"guides","section":"guides","headings":["Frontend","Backend"],"subHeadings":["Global events","Window","Global events","Window"],"code":["ts","rust"],"text":"# Events The Tauri event system is a multi-producer multi-consumer communication\nprimitive that allows message passing between the frontend and the backend. It\nis analogous to the command system, but payload type check must be written on\nthe event handler and it simplifies communication from the backend to the\nfrontend, working like a channel. A Tauri application can listen and emit to\nglobal and window-specific events. Usage from the frontend and the backend are\ndescribed below. ## Frontend The event system is accessible on the frontend on\nthe `event` and `window` modules of the `@tauri-apps/api` package. ### Global\nevents To use the global event channel, import the `event` module and use the\n`emit` and `listen` functions: ```ts import { emit, listen } from\n'@tauri-apps/api/event' // listen to the `click` event and get a function to\nremove the event listener // there's also a `once` function that subscribes to\nan event and automatically unsubscribes the listener on the first event const\nunlisten = await listen('click', event => { // event.event is the event name\n(useful if you want to use a single callback fn for multiple event types) //\nevent.payload is the payload object }) // emits the `click` event with the\nobject payload emit('click', { theMessage: 'Tauri is awesome!' }) ``` ###\nWindow-specific events Window-specific events are exposed on the `window`\nmodule. ```ts import { appWindow, WebviewWindow } from '@tauri-apps/api/window'\n// emit an event that are only visible to the current window\nappWindow.emit('event', { message: 'Tauri is awesome!' }) // create a new\nwebview window and emit an event only to that window const webview = new\nWebviewWindow('window') webview.emit('event') ``` ## Backend On the backend, the\nglobal event channel is exposed on the `App` struct, and window-specific events\ncan be emitted using the `Window` trait. ### Global events ```rust use\ntauri::Manager; // the payload type must implement `Serialize`. // for global\nevents, it also must implement `Clone`. #[derive(Clone, serde::Serialize)]\nstruct Payload { message: String, } fn main() { tauri::Builder::default()\n.setup(|app| { // listen to the `event-name` (emitted on any window) let id =\napp.listen_global(\"event-name\", |event| { println!(\"got event-name with payload\n{:?}\", event.payload()); }); // unlisten to the event using the `id` returned on\nthe `listen_global` function // an `once_global` API is also exposed on the\n`App` struct app.unlisten(id); // emit the `event-name` event to all webview\nwindows on the frontend app.emit_all(\"event-name\", Payload { message: \"Tauri is\nawesome!\".into() }).unwrap(); Ok(()) }) .run(tauri::generate_context!())\n.expect(\"failed to run app\"); } ``` ### Window-specific events To use the\nwindow-specific event channel, a `Window` object can be obtained on a command\nhandler or with the `get_window` function: ```rust use tauri::{Manager, Window};\n// the payload type must implement `Serialize`. #[derive(serde::Serialize)]\nstruct Payload { message: String, } // init a background process on the command,\nand emit periodic events only to the window that used the command\n#[tauri::command] fn init_process(window: Window) { std::thread::spawn(move || {\nloop { window.emit(\"event-name\", Payload { message: \"Tauri is awesome!\".into()\n}).unwrap(); } }); } fn main() { tauri::Builder::default() .setup(|app| { //\n`main` here is the window label; it is defined on the window creation or under\n`tauri.conf.json` // the default value is `main`. note that it must be unique\nlet main_window = app.get_window(\"main\").unwrap(); // listen to the `event-name`\n(emitted on the `main` window) let id = main_window.listen(\"event-name\", |event|\n{ println!(\"got window event-name with payload {:?}\", event.payload()); }); //\nunlisten to the event using the `id` returned on the `listen` function // an\n`once` API is also exposed on the `Window` struct main_window.unlisten(id); //\nemit the `event-name` event to the `main` window main_window.emit(\"event-name\",\nPayload { message: \"Tauri is awesome!\".into() }).unwrap(); Ok(()) })\n.invoke_handler(tauri::generate_handler![init_process])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ```","url":"https://tauri.studio/docs/guides/events"},{"id":"prose_docs_guides_icons_md","title":"Icons","area":"guides","section":"guides","headings":[],"subHeadings":[],"code":["sh","json"],"text":"# Icons import Command from '@theme/Command' Tauri ships with a default iconset\nbased on its logo. This is probably NOT what you want when you ship your\napplication. To remedy this common situation, Tauri provides the `icon` command\nthat will take an input file (\"./app-icon.png\" by default) and create all the\nicons needed for the various platforms: ```sh Options --help, -h Displays this\nmessage --log, l Logging [boolean] --icon, i Source icon (png, 1240x1240 with\ntransparency) --target, t Target folder (default: 'src-tauri/icons')\n--compression, c Compression type [pngquant|optipng|zopfli] ``` These will be\nplaced in your `src-tauri/icons` folder where they will automatically be\nincluded in your built app. If you need to source your icons from some other\nlocation, you can edit this part of the `src-tauri/tauri.conf.json` file:\n```json { \"tauri\": { \"bundle\": { \"icon\": [ \"icons/32x32.png\",\n\"icons/128x128.png\", \"icons/128x128@2x.png\", \"icons/icon.icns\", \"icons/icon.ico\"\n] } } } ``` :::info Note on filetypes - icon.icns = macOS - icon.ico = MS\nWindows - \\*.png = Linux :::","url":"https://tauri.studio/docs/guides/icons"},{"id":"prose_docs_guides_menu_md","title":"Window Menu","area":"guides","section":"guides","headings":[],"subHeadings":["Creating a menu","Adding the menu to all windows","Adding the menu to a specific window","Listening to events on custom menu items","Updating menu items"],"code":["rust"],"text":"# Window Menu Native application menus can be attached to a window. ### Creating\na menu To create a native window menu, import the `Menu`, `Submenu`, `MenuItem`\nand `CustomMenuItem` types. The `MenuItem` enum contains a collection of\nplatform-specific items (currently not implemented on Windows). The\n`CustomMenuItem` allows you to create your own menu items and add special\nfunctionality to them. ```rust use tauri::{CustomMenuItem, Menu, MenuItem,\nSubmenu}; ``` Create a `Menu` instance: ```rust // here `\"quit\".to_string()`\ndefines the menu item id, and the second parameter is the menu item label. let\nquit = CustomMenuItem::new(\"quit\".to_string(), \"Quit\"); let close =\nCustomMenuItem::new(\"close\".to_string(), \"Close\"); let submenu =\nSubmenu::new(\"File\", Menu::new().add_item(quit).add_item(close)); let menu =\nMenu::new() .add_native_item(MenuItem::Copy)\n.add_item(CustomMenuItem::new(\"hide\", \"Hide\")) .add_submenu(submenu); ``` ###\nAdding the menu to all windows The defined menu can be set to all windows using\nthe `menu` API on the `tauri::Builder` struct: ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem, Submenu}; fn main() { let menu =\nMenu::new(); // configure the menu tauri::Builder::default() .menu(menu)\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Adding the menu to a specific window You can create a\nwindow and set the menu to be used. This allows defining a specific menu set for\neach application window. ```rust use tauri::{CustomMenuItem, Menu, MenuItem,\nSubmenu}; use tauri::WindowBuilder; fn main() { let menu = Menu::new(); //\nconfigure the menu tauri::Builder::default() .create_window(\n\"main-window\".to_string(), tauri::WindowUrl::App(\"index.html\".into()), move\n|window_builder, webview_attributes| { (window_builder.menu(menu),\nwebview_attributes) }, ) .run(tauri::generate_context!()) .expect(\"error while\nrunning tauri application\"); } ``` ### Listening to events on custom menu items\nEach `CustomMenuItem` triggers an event when clicked. Use the `on_menu_event`\nAPI to handle them, either on the global `tauri::Builder` or on an specific\nwindow. #### Listening to events on global menus ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem}; fn main() { let menu = vec![]; //\ninsert the menu array here tauri::Builder::default() .menu(menu)\n.on_menu_event(|event| { match event.menu_item_id() { \"quit\" => {\nstd::process::exit(0); } \"close\" => { event.window().close().unwrap(); } _ => {}\n} }) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` #### Listening to events on window menus ```rust use\ntauri::{CustomMenuItem, Menu, MenuItem}; use tauri::{Manager, WindowBuilder}; fn\nmain() { let menu = vec![]; // insert the menu array here\ntauri::Builder::default() .create_window( \"main-window\".to_string(),\ntauri::WindowUrl::App(\"index.html\".into()), move |window_builder,\nwebview_attributes| { (window_builder.menu(menu), webview_attributes) }, )\n.setup(|app| { let window = app.get_window(\"main-window\").unwrap(); let window_\n= window.clone(); window.on_menu_event(move |event| { match\nevent.menu_item_id().as_str() { \"quit\" => { std::process::exit(0); } \"close\" =>\n{ window_.close().unwrap(); } _ => {} } }); Ok(()) })\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Updating menu items The `Window` struct has a\n`menu_handle` method, which allows updating menu items: ```rust fn main() {\ntauri::Builder::default() .setup(|app| { let main_window =\napp.get_window(\"main\").unwrap(); let menu_handle = main_window.menu_handle();\nstd::thread::spawn(move || { // you can also `set_selected`, `set_enabled` and\n`set_native_image` (macOS only). menu_handle.get_item(\"item_id\").set_title(\"New\ntitle\"); }) Ok(()) }) } ```","url":"https://tauri.studio/docs/guides/menu"},{"id":"prose_docs_guides_multiwindow_md","title":"Multiwindow","area":"guides","section":"guides","headings":[],"subHeadings":[],"code":[],"text":"# Multiwindow Manage multiple windows on a single application.","url":"https://tauri.studio/docs/guides/multiwindow"},{"id":"prose_docs_guides_plugin_md","title":"Tauri Plugins","area":"guides","section":"guides","headings":["Using a Plugin","Writing a Plugin","Writing a Plugin"],"subHeadings":["API package","Conventions","Advanced"],"code":["rust","sh","ts"],"text":"# Tauri Plugins Plugins allow you to hook into the Tauri application lifecycle\nand introduce new commands. ## Using a Plugin To use a plugin, just pass the\nplugin instance to the App's `plugin` method: ```rust fn main() {\ntauri::Builder::default() .plugin(my_awesome_plugin::init())\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ``` ## Writing\na Plugin Plugins are reusable extensions to the Tauri API that solve common\nproblems. They are also a very convenient way to structure your own code base!\nIf you intend to share your plugin with others, we provide a ready-made\ntemplate! With the tauri-cli installed just run: ```sh tauri plugin init --name\nawesome ``` ### API package By default consumers of your plugin can call\nprovided commands like this: ```ts import { invoke } from '@tauri-apps/api'\ninvoke('plugin:awesome|do_something') ``` where `awesome` will be replaced by\nyour plugin name. This isn't very convenient however, so it's common for plugins\nto provide a so called _API package_, a JavaScript package that provides\nconvenient access to your commands. > An example of this is the\n[tauri-plugin-store](https://github.com/tauri-apps/tauri-plugin-store), that\nprovides a convenient class structure to accessing a store. > You can scaffold a\nplugin with attached API package like this: ```sh tauri plugin init --name\nawesome --api ``` ## Writing a Plugin Using the `tauri::plugin::Builder` you can\ndefine plugins similar to how you define your app: ```rust use\ntauri::plugin::{Builder, TauriPlugin}; // the plugin custom command handlers if\nyou choose to extend the API. #[tauri::command] // this will be accessible with\n`invoke('plugin:awesome|initialize')`. // where `awesome` is the plugin name. fn\ninitialize() {} #[tauri::command] // this will be accessible with\n`invoke('plugin:awesome|do_something')`. fn do_something() {} pub fn init() ->\nTauriPlugin { Builder::new(\"awesome\")\n.invoke_handler(tauri::generate_handler![initialize, do_something]) .build() }\n``` Plugins can setup and maintain state, just like your app can: ```rust use\ntauri::{ AppHandle, Runtime, State plugin::{Builder, TauriPlugin} };\n#[derive(Default)] struct MyState { } #[tauri::command] // this will be\naccessible with `invoke('plugin:awesome|do_something')`. fn do_something(_app:\nAppHandle, state: State<'_, MyState>) { // you can access `MyState` here! }\nBuilder::new(\"awesome\") .invoke_handler(tauri::generate_handler![initialize,\ndo_something]) .setup(|app_handle| { // setup plugin specific state here\napp.manage(MyState::default()) Ok(()) }) .build() ``` ### Conventions - The\ncrate exports an `init` method to create the plugin. - Plugins should have a\nclear name with `tauri-plugin-` prefix. - Include `tauri-plugin` keyword in\n`Cargo.toml`/`package.json`. - Document your plugin in English. - Add an example\napp showcasing your plugin. ### Advanced Instead of relying on the\n`tauri::plugin::TauriPlugin` struct returned by `tauri::plugin::Builder::build`,\nyou can implement the `tauri::plugin::Plugin` yourself. This allows you to have\nfull control over the associated data. Note that each function on the `Plugin`\ntrait is optional, except the `name` function. ```rust use\ntauri::{plugin::{Plugin, Result as PluginResult}, Runtime, PageLoadPayload,\nWindow, Invoke, AppHandle}; struct MyAwesomePlugin { invoke_handler: Box) + Send\n+ Sync>, // plugin state, configuration fields } // the plugin custom command\nhandlers if you choose to extend the API. #[tauri::command] // this will be\naccessible with `invoke('plugin:awesome|initialize')`. // where `awesome` is the\nplugin name. fn initialize() {} #[tauri::command] // this will be accessible\nwith `invoke('plugin:awesome|do_something')`. fn do_something() {} impl\nMyAwesomePlugin { // you can add configuration fields here, // see\nhttps://doc.rust-lang.org/1.0.0/style/ownership/builders.html pub fn new() ->\nSelf { Self { invoke_handler: Box::new(tauri::generate_handler![initialize,\ndo_something]), } } } impl Plugin for MyAwesomePlugin { /// The plugin name.\nMust be defined and used on the `invoke` calls. fn name(&self) -> &'static str {\n\"awesome\" } /// The JS script to evaluate on initialization. /// Useful when\nyour plugin is accessible through `window` /// or needs to perform a JS task on\napp initialization /// e.g. \"window.awesomePlugin = { ... the plugin interface\n}\" fn initialization_script(&self) -> Option { None } /// initialize plugin with\nthe config provided on `tauri.conf.json > plugins > $yourPluginName` or the\ndefault value. fn initialize(&mut self, app: &AppHandle, config:\nserde_json::Value) -> PluginResult<()> { Ok(()) } /// Callback invoked when the\nWindow is created. fn created(&mut self, window: Window) {} /// Callback invoked\nwhen the webview performs a navigation. fn on_page_load(&mut self, window:\nWindow, payload: PageLoadPayload) {} /// Extend the invoke handler. fn\nextend_api(&mut self, message: Invoke) { (self.invoke_handler)(message) } } ```","url":"https://tauri.studio/docs/guides/plugin"},{"id":"prose_docs_guides_splashscreen_md","title":"Splashscreen","area":"guides","section":"guides","headings":[],"subHeadings":["Setup","Waiting for Webpage","Waiting for Rust"],"code":["diff",null],"text":"# Splashscreen If your webpage could take some time to load, or if you need to\nrun an initialization procedure in Rust before displaying your main window, a\nsplashscreen could improve the loading experience for the user. ### Setup First,\ncreate a `splashscreen.html` in your `distDir` that contains the HTML code for a\nsplashscreen. Then, update your `tauri.conf.json` like so: ```diff \"windows\": [\n{ \"title\": \"Tauri App\", \"width\": 800, \"height\": 600, \"resizable\": true,\n\"fullscreen\": false, + \"visible\": false // Hide the main window by default }, //\nAdd the splashscreen window + { + \"width\": 400, + \"height\": 200, +\n\"decorations\": false, + \"url\": \"splashscreen.html\", + \"label\": \"splashscreen\" +\n} ] ``` Now, your main window will be hidden and the splashscreen window will\nshow when your app is launched. Next, you'll need a way to close the\nsplashscreen and show the main window when your app is ready. How you do this\ndepends on what you are waiting for before closing the splashscreen. ### Waiting\nfor Webpage If you are waiting for your web code, you'll want to create a\n`close_splashscreen` [command](command.md). ```rust title=src-tauri/main.rs use\ntauri::Manager; // Create the command: // This command must be async so that it\ndoesn't run on the main thread. #[tauri::command] async fn\nclose_splashscreen(window: tauri::Window) { // Close splashscreen if let\nSome(splashscreen) = window.get_window(\"splashscreen\") {\nsplashscreen.close().unwrap(); } // Show main window\nwindow.get_window(\"main\").unwrap().show().unwrap(); } // Register the command:\nfn main() { tauri::Builder::default() // Add this line\n.invoke_handler(tauri::generate_handler![close_splashscreen])\n.run(tauri::generate_context!()) .expect(\"failed to run app\"); } ``` Then, you\ncan call it from your JS: ```js // With the Tauri API npm package: import {\ninvoke } from '@tauri-apps/api/tauri' // With the Tauri global script: const\ninvoke = window.__TAURI__.invoke document.addEventListener('DOMContentLoaded',\n() => { // This will wait for the window to load, but you could // run this\nfunction on whatever trigger you want invoke('close_splashscreen') }) ``` ###\nWaiting for Rust If you are waiting for Rust code to run, put it in the `setup`\nfunction handler so you have access to the `App` instance: ```rust\ntitle=src-tauri/main.rs use tauri::Manager; fn main() {\ntauri::Builder::default() .setup(|app| { let splashscreen_window =\napp.get_window(\"splashscreen\").unwrap(); let main_window =\napp.get_window(\"main\").unwrap(); // we perform the initialization code on a new\ntask so the app doesn't freeze tauri::async_runtime::spawn(async move { //\ninitialize your app here instead of sleeping :) println!(\"Initializing...\");\nstd::thread::sleep(std::time::Duration::from_secs(2)); println!(\"Done\ninitializing.\"); // After it's done, close the splashscreen and display the main\nwindow splashscreen_window.close().unwrap(); main_window.show().unwrap(); });\nOk(()) }) .run(tauri::generate_context!()) .expect(\"failed to run app\"); } ```","url":"https://tauri.studio/docs/guides/splashscreen"},{"id":"prose_docs_guides_system_tray_md","title":"System Tray","area":"guides","section":"guides","headings":[],"subHeadings":["Setup","Creating a system tray","Configuring a system tray context menu","Configure the app system tray","Listening to system tray events","Updating system tray"],"code":["json","rust"],"text":"# System Tray Native application system tray. ### Setup Configure the\n`systemTray` object on `tauri.conf.json`: ```json { \"tauri\": { \"systemTray\": {\n\"iconPath\": \"icons/icon.png\", \"iconAsTemplate\": true } } } ``` The `iconPath` is\npointed to a PNG file on macOS and Linux, and a `.ico` file must exist for\nWindows support. The `iconAsTemplate` is a boolean value that determines whether\nthe image represents a [Template Image] on macOS. ### Creating a system tray To\ncreate a native system tray, import the `SystemTray` type: ```rust use\ntauri::SystemTray; ``` Initialize a new tray instance: ```rust let tray =\nSystemTray::new(); ``` ### Configuring a system tray context menu Optionally you\ncan add a context menu that is visible when the tray icon is right clicked.\nImport the `SystemTrayMenu`, `SystemTrayMenuItem` and `CustomMenuItem` types:\n```rust use tauri::{CustomMenuItem, SystemTrayMenu, SystemTrayMenuItem}; ```\nCreate the `SystemTrayMenu`: ```rust // here `\"quit\".to_string()` defines the\nmenu item id, and the second parameter is the menu item label. let quit =\nCustomMenuItem::new(\"quit\".to_string(), \"Quit\"); let hide =\nCustomMenuItem::new(\"hide\".to_string(), \"Hide\"); let tray_menu =\nSystemTrayMenu::new() .add_item(quit)\n.add_native_item(SystemTrayMenuItem::Separator) .add_item(hide); ``` Add the\ntray menu to the `SystemTray` instance: ```rust let tray =\nSystemTray::new().with_menu(tray_menu); ``` ### Configure the app system tray\nThe created `SystemTray` instance can be set using the `system_tray` API on the\n`tauri::Builder` struct: ```rust use tauri::{CustomMenuItem, SystemTray,\nSystemTrayMenu}; fn main() { let tray_menu = SystemTrayMenu::new(); // insert\nthe menu items here let system_tray = SystemTray::new() .with_menu(tray_menu);\ntauri::Builder::default() .system_tray(system_tray)\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Listening to system tray events Each `CustomMenuItem`\ntriggers an event when clicked. Also, Tauri emits tray icon click events. Use\nthe `on_system_tray_event` API to handle them: ```rust use\ntauri::{CustomMenuItem, SystemTray, SystemTrayMenu}; use tauri::Manager; fn\nmain() { let tray_menu = SystemTrayMenu::new(); // insert the menu items here\ntauri::Builder::default() .system_tray(SystemTray::new().with_menu(tray_menu))\n.on_system_tray_event(|app, event| match event { SystemTrayEvent::LeftClick {\nposition: _, size: _, .. } => { println!(\"system tray received a left click\"); }\nSystemTrayEvent::RightClick { position: _, size: _, .. } => { println!(\"system\ntray received a right click\"); } SystemTrayEvent::DoubleClick { position: _,\nsize: _, .. } => { println!(\"system tray received a double click\"); }\nSystemTrayEvent::MenuItemClick { id, .. } => { match id.as_str() { \"quit\" => {\nstd::process::exit(0); } \"hide\" => { let window =\napp.get_window(\"main\").unwrap(); window.hide().unwrap(); } _ => {} } } _ => {}\n}) .run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` ### Updating system tray The `AppHandle` struct has a\n`tray_handle` method, which returns a handle to the system tray allowing\nupdating tray icon and context menu items: #### Updating context menu items\n```rust use tauri::{CustomMenuItem, SystemTray, SystemTrayMenu}; use\ntauri::Manager; fn main() { let tray_menu = SystemTrayMenu::new(); // insert the\nmenu items here tauri::Builder::default()\n.system_tray(SystemTray::new().with_menu(tray_menu)) .on_system_tray_event(|app,\nevent| match event { SystemTrayEvent::MenuItemClick { id, .. } => { // get a\nhandle to the clicked menu item // note that `tray_handle` can be called\nanywhere, // just get a `AppHandle` instance with `app.handle()` on the setup\nhook // and move it to another function or thread let item_handle =\napp.tray_handle().get_item(&id); match id.as_str() { \"hide\" => { let window =\napp.get_window(\"main\").unwrap(); window.hide().unwrap(); // you can also\n`set_selected`, `set_enabled` and `set_native_image` (macOS only).\nitem_handle.set_title(\"Show\").unwrap(); } _ => {} } } _ => {} })\n.run(tauri::generate_context!()) .expect(\"error while running tauri\napplication\"); } ``` #### Updating tray icon Note that `tauri::Icon` must be a\n`Path` variant on Linux, and `Raw` variant on Windows and macOS. ```rust\napp.tray_handle().set_icon(tauri::Icon::Raw(include_bytes!(\"../path/to/myicon.ico\"))).unwrap();\n``` [Template Image]:\nhttps://developer.apple.com/documentation/appkit/nsimage/1520017-template?language=objc","url":"https://tauri.studio/docs/guides/system-tray"},{"id":"prose_docs_guides_window_customization_md","title":"Window Customization","area":"guides","section":"guides","headings":["Configuration","Creating a Custom Titlebar"],"subHeadings":["CSS","HTML","JS"],"code":["css","html","js"],"text":"` tag: ```html\nminimize [https://api.iconify.design/mdi:window-minimize.svg]\nmaximize [https://api.iconify.design/mdi:window-maximize.svg]\nclose [https://api.iconify.design/mdi:close.svg]\n``` Note that you may need to move the rest of your content down so that the\ntitlebar doesn't cover it. ### JS Finally, you'll need to make the buttons work:\n```js import { appWindow } from '@tauri-apps/api/window' document\n.getElementById('titlebar-minimize') .addEventListener('click', () =>\nappWindow.minimize()) document .getElementById('titlebar-maximize')\n.addEventListener('click', () => appWindow.toggleMaximize()) document\n.getElementById('titlebar-close') .addEventListener('click', () =>\nappWindow.close()) ```","url":"https://tauri.studio/docs/guides/window-customization"},{"id":"prose_docs_testing_mocking_md","title":"Mocking Tauri APIs","area":"testing","section":"testing","headings":["IPC Requests","Windows"],"subHeadings":[],"code":["js"],"text":"# Mocking Tauri APIs When writing your frontend tests, having a \"fake\" Tauri\nenvironment to simulate windows or intercept IPC calls is common, so-called\n*mocking*. The [`@tauri-apps/api/mocks`] module provides some helpful tools to\nmake this easier for you: :::caution Remember to clear mocks after each test run\nto undo mock state changes between runs! See [`clearMocks()`] docs for more\ninfo. ::: ## IPC Requests Most commonly, you want to intercept IPC requests;\nthis can be helpful in a variety of situations: - Ensure the correct backend\ncalls are made - Simulate different results from backend functions Tauri\nprovides the mockIPC function to intercept IPC requests. You can find more about\nthe specific API in detail [here][`mockIPC()`]. :::note The following examples\nuse [Vitest], but you can use any other frontend testing library such as jest.\n::: ```js import { beforeAll, expect, test } from \"vitest\"; import {\nrandomFillSync } from \"crypto\"; import { mockIPC } from \"@tauri-apps/api/mocks\"\nimport { invoke } from \"@tauri-apps/api/tauri\"; // jsdom doesn't come with a\nWebCrypto implementation beforeAll(() => { //@ts-ignore window.crypto = {\ngetRandomValues: function (buffer) { return randomFillSync(buffer); }, }; });\ntest(\"invoke simple\", async () => { mockIPC((cmd, args) => { // simulated rust\ncommand called \"add\" that just adds two numbers if(cmd === \"add\") { return\n(args.a as number) + (args.b as number) } }) expect(invoke(\"add\", { a: 12, b: 15\n})).resolves.toBe(27) }) ``` Sometimes you want to track more information about\nan IPC call; how many times was the command invoked? Was it invoked at all? You\ncan use [`mockIPC()`] with other spying and mocking tools to test this: ```js\nimport { beforeAll, expect, test, vi } from \"vitest\"; import { randomFillSync }\nfrom \"crypto\"; import { mockIPC } from \"@tauri-apps/api/mocks\" import { invoke }\nfrom \"@tauri-apps/api/tauri\"; // jsdom doesn't come with a WebCrypto\nimplementation beforeAll(() => { //@ts-ignore window.crypto = { getRandomValues:\nfunction (buffer) { return randomFillSync(buffer); }, }; }); test(\"invoke\",\nasync () => { mockIPC((cmd, args) => { // simulated rust command called \"add\"\nthat just adds two numbers if(cmd === \"add\") { return (args.a as number) +\n(args.b as number) } }) // we can use the spying tools provided by vitest to\ntrack the mocked function const spy = vi.spyOn(window, \"__TAURI_IPC__\")\nexpect(invoke(\"add\", { a: 12, b: 15 })).resolves.toBe(27)\nexpect(spy).toHaveBeenCalled() }) ``` ## Windows Sometimes you have\nwindow-specific code (a splash screen window, for example), so you need to\nsimulate different windows. You can use the [`mockWindows()`] method to create\nfake window labels. The first string identifies the \"current\" window (i.e., the\nwindow your JavaScript believes itself in), and all other strings are treated as\nadditional windows. :::note [`mockWindows()`] only fakes the existence of\nwindows but no window properties. To simulate window properties, you need to\nintercept the correct calls using [`mockIPC()`] ::: ```js import { beforeAll,\nexpect, test } from \"vitest\"; import { randomFillSync } from \"crypto\"; import {\nmockWindows } from \"@tauri-apps/api/mocks\" // jsdom doesn't come with a\nWebCrypto implementation beforeAll(() => { //@ts-ignore window.crypto = {\ngetRandomValues: function (buffer) { return randomFillSync(buffer); }, }; });\ntest(\"invoke\", async () => { mockWindows(\"main\", \"second\", \"third\"); const {\ngetCurrent, getAll } = await import(\"@tauri-apps/api/window\");\nexpect(getCurrent()).toHaveProperty(\"label\", \"main\") expect(getAll().map(w =>\nw.label)).toEqual([\"main\", \"second\", \"third\"]) }) ``` [`@tauri-apps/api/mocks`]:\n../api/js/modules/mocks.md [`mockIPC()`]: ../api/js/modules/mocks.md#mockipc\n[`mockWindows()`]: ../api/js/modules/mocks.md#mockwindows [`clearMocks()`]:\n../api/js/modules/mocks.md#clearmocks [Vitest]: https://vitest.dev","url":"https://tauri.studio/docs/testing/mocking"},{"id":"prose_docs_testing_webdriver_ci_md","title":"Continuous Integration","area":"testing","section":"webdriver","headings":[],"subHeadings":[],"code":["yaml"],"text":"# Continuous Integration Utilizing Linux and some programs to create a fake\ndisplay, it is possible to run [WebDriver] tests with [`tauri-driver`] on your\nCI. The following example uses the [WebdriverIO] example we [previously built\ntogether] and GitHub Actions. This means the following assumptions: 1. The Tauri\napplication is in the repository root and the binary builds when running `cargo\nbuild --release`. 2. The [WebDriverIO] test runner is in the\n`webdriver/webdriverio` directory and runs when `yarn test` is used in that\ndirectory. The following is a commented GitHub Actions workflow file at\n`.github/workflows/webdriver.yml` ```yaml # run this action when the repository\nis pushed to on: [ push ] # the name of our workflow name: WebDriver jobs: # a\nsingle job named test test: # the display name the test job name: WebDriverIO\nTest Runner # we want to run on the latest linux environment runs-on:\nubuntu-latest # the steps our job runs **in order** steps: # checkout the code\non the workflow runner - uses: actions/checkout@v2 # install system dependencies\nthat Tauri needs to compile on Linux. # note the extra dependencies for\n`tauri-driver` to run which are `webkit2gtk-driver` and `xvfb` - name: Tauri\ndependencies run: >- sudo apt-get update && sudo apt-get install -y libgtk-3-dev\nlibgtksourceview-3.0-dev webkit2gtk-4.0 libappindicator3-dev webkit2gtk-driver\nxvfb # install the latest Rust stable - name: Rust stable uses:\nactions-rs/toolchain@v1 with: toolchain: stable # we run our rust tests before\nthe webdriver tests to avoid testing a broken application - name: Cargo test\nuses: actions-rs/cargo@v1 with: command: test # build a release build of our\napplication to be used during our WebdriverIO tests - name: Cargo build uses:\nactions-rs/cargo@v1 with: command: build args: --release # install the latest\nstable node version at the time of writing - name: Node v16 uses:\nactions/setup-node@v2 with: node-version: 16.x # install our Node.js\ndependencies with Yarn - name: Yarn install run: yarn install working-directory:\nwebdriver/webdriverio # install the latest version of `tauri-driver`. # note:\nthe tauri-driver version is independent of any other Tauri versions - name:\nInstall tauri-driver uses: actions-rs/cargo@v1 with: command: install args:\ntauri-driver # run the WebdriverIO test suite. # we run it through `xvfb-run`\n(the dependency we installed earlier) to have a fake # display server which\nallows our application to run headless without any changes to the code - name:\nWebdriverIO run: xvfb-run yarn test working-directory: webdriver/webdriverio ```\n[WebDriver]: https://www.w3.org/TR/webdriver/ [`tauri-driver`]:\nhttps://crates.io/crates/tauri-driver [WebdriverIO]: https://webdriver.io/\n[previously built together]: example/webdriverio","url":"https://tauri.studio/docs/testing/webdriver/ci"},{"id":"prose_docs_testing_webdriver_introduction_md","title":"Introduction","area":"testing","section":"webdriver","headings":["System Dependencies","Example Application"],"subHeadings":["Linux","Windows"],"code":["sh"],"text":":::caution Currently in pre-alpha Webdriver support for Tauri is still in\npre-alpha. Tooling that is dedicated to it, such as [tauri-driver], is still in\nactive development and may change as necessary over time. Additionally, only\nWindows and Linux are currently supported. ::: [WebDriver] is a standardized\ninterface to interact with web documents primarily intended for automated\ntesting. Tauri supports the [WebDriver] interface by leveraging the native\nplatform's [WebDriver] server underneath a cross-platform wrapper\n[`tauri-driver`]. ## System Dependencies Install the latest [`tauri-driver`] or\nupdate an existing installation by running: ```sh cargo install tauri-driver ```\nBecause we currently utilize the platform's native [WebDriver] server, there are\nsome requirements for running [`tauri-driver`] on supported platforms. Platform\nsupport is currently limited to Linux and Windows. ### Linux We use\n`WebKitWebDriver` on Linux platforms. Check if this binary exists already\n(command `which WebKitWebDriver`) as some distributions bundle it with the\nregular WebKit package. Other platforms may have a separate package for them,\nsuch as `webkit2gtk-driver` on Debian-based distributions. ### Windows Make sure\nto grab the version of [Microsoft Edge Driver] that matches your Windows' Edge\nversion that the application is being built and tested on. This should almost\nalways be the latest stable version on up-to-date Windows installs. If the two\nversions do not match, you may experience your WebDriver testing suite hanging\nwhile trying to connect. The download contains a binary called\n`msedgedriver.exe`. [`tauri-driver`] looks for that binary in the `$PATH` so\nmake sure it's either available on the path or use the `--native-driver` option\non [`tauri-driver`]. You may want to download this automatically as part of the\nCI setup process to ensure the Edge, and Edge Driver versions stay in sync on\nWindows CI machines. A guide on how to do this may be added at a later date. ##\nExample Application The [next section](example/setup) of the guide shows\nstep-by-step how to create a minimal example application that is tested with\nWebDriver. If you prefer to see the result of the guide and look over a finished\nminimal codebase that utilizes it, you can look at\nhttps://github.com/chippers/hello_tauri. That example also comes with a CI\nscript to test with GitHub actions, but you may still be interested in the\n[WebDriver CI](ci) guide as it explains the concept a bit more. [WebDriver]:\nhttps://www.w3.org/TR/webdriver/ [`tauri-driver`]:\nhttps://crates.io/crates/tauri-driver [tauri-driver]:\nhttps://crates.io/crates/tauri-driver [Microsoft Edge Driver]:\nhttps://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/","url":"https://tauri.studio/docs/testing/webdriver/introduction"},{"id":"prose_docs_testing_webdriver_example_selenium_md","title":"Selenium","area":"testing","parentSection":"webdriver","section":"example","headings":["Create a Directory for the Tests","Initializing a Selenium Project","Testing","Running the Test Suite"],"subHeadings":[],"code":["sh",null,"text"],"text":"import Tabs from '@theme/Tabs' import TabItem from '@theme/TabItem' # Selenium\n:::info Example Application This [Selenium] guide expects you to have already\ngone through the [example Application setup] to follow step-by-step. The general\ninformation may still be helpful otherwise. ::: This WebDriver testing example\nwill use [Selenium] and a popular Node.js testing suite. You are expected to\nalready have Node.js installed, along with `npm` or `yarn` although the\n[finished example project] uses `yarn`. ## Create a Directory for the Tests\nLet's create a space to write these tests in our project. We will be using a\nnested directory for this example project as we will later also go over other\nframeworks, but typically you will only need to use one. Create the directory we\nwill use with `mkdir -p webdriver/selenium`. The rest of this guide will assume\nyou are inside the `webdriver/selenium` directory. ## Initializing a Selenium\nProject We will be using a pre-existing `package.json` to bootstrap this test\nsuite because we have already chosen specific dependencies to use and want to\nshowcase a simple working solution. The bottom of this section has a collapsed\nguide on how to set it up from scratch. `package.json`: ```json { \"name\":\n\"selenium\", \"version\": \"1.0.0\", \"private\": true, \"scripts\": { \"test\": \"mocha\" },\n\"dependencies\": { \"chai\": \"^4.3.4\", \"mocha\": \"^9.0.3\", \"selenium-webdriver\":\n\"^4.0.0-beta.4\" } } ``` We have a script that runs [Mocha] as a test framework\nexposed as the `test` command. We also have various dependencies that we will be\nusing to run the tests. [Mocha] as the testing framework, [Chai] as the\nassertion library, and [`selenium-webdriver`] which is the Node.js [Selenium]\npackage. Click me if you want to see how to set a project up from scratch If you\nwant to install the dependencies from scratch, just run the following command.\n```sh npm install mocha chai selenium-webdriver ``` ```sh yarn add mocha chai\nselenium-webdriver ``` I suggest also adding a `\"test\": \"mocha\"` item in the\n`package.json` `\"scripts\"` key so that running Mocha can be called simply with\n```sh npm test ``` ```sh yarn test ``` ## Testing Unlike the [WebdriverIO Test\nSuite](webdriverio#config), Selenium does not come out of the box with a Test\nSuite and leaves it up to the developer to build those out. We chose [Mocha],\nwhich is pretty neutral and not related to WebDrivers, so our script will need\nto do a bit of work to set up everything for us in the correct order. [Mocha]\nexpects a testing file at `test/test.js` by default, so let's create that file\nnow. `test/test.js`: ```js const os = require(\"os\"); const path =\nrequire(\"path\"); const { expect } = require(\"chai\"); const { spawn, spawnSync }\n= require(\"child_process\"); const { Builder, By, Capabilities } =\nrequire(\"selenium-webdriver\"); // create the path to the expected application\nbinary const application = path.resolve( __dirname, \"..\", \"..\", \"..\", \"target\",\n\"release\", \"hello-tauri-webdriver\" ); // keep track of the webdriver instance we\ncreate let driver; // keep track of the tauri-driver process we start let\ntauriDriver; before(async function() { // set timeout to 2 minutes to allow the\nprogram to build if it needs to this.timeout(120000) // ensure the program has\nbeen built spawnSync(\"cargo\", [\"build\", \"--release\"]); // start tauri-driver\ntauriDriver = spawn( path.resolve(os.homedir(), \".cargo\", \"bin\",\n\"tauri-driver\"), [], { stdio: [null, process.stdout, process.stderr] } ); const\ncapabilities = new Capabilities(); capabilities.set(\"tauri:options\", {\napplication }); capabilities.setBrowserName(\"wry\"); // start the webdriver\nclient driver = await new Builder() .withCapabilities(capabilities)\n.usingServer(\"http://localhost:4444/\") .build(); }); after(async function() { //\nstop the webdriver session await driver.quit(); // kill the tauri-driver process\ntauriDriver.kill(); }); describe(\"Hello Tauri\", () => { it(\"should be cordial\",\nasync () => { const text = await driver.findElement(By.css(\"body >\nh1\")).getText(); expect(text).to.match(/^[hH]ello/); }); it(\"should be excited\",\nasync () => { const text = await driver.findElement(By.css(\"body >\nh1\")).getText(); expect(text).to.match(/!$/); }); it(\"should be easy on the\neyes\", async () => { // selenium returns color css values as rgb(r, g, b) const\ntext = await driver.findElement(By.css(\"body\")).getCssValue(\"background-color\");\nconst rgb = text.match(/^rgb\\((?\\d+), (?\\d+), (?\\d+)\\)$/).groups;\nexpect(rgb).to.have.all.keys('r','g','b'); const luma = 0.2126 * rgb.r + 0.7152\n* rgb.g + 0.0722 * rgb.b ; expect(luma).to.be.lessThan(100) }); }); ``` If you\nare familiar with JS testing frameworks, `describe`, `it`, and `expect` should\nlook familiar. We also have semi-complex `before()` and `after()` callbacks to\nsetup and teardown mocha. Lines that are not the tests themselves have comments\nexplaining the setup and teardown code. If you were familiar with the Spec file\nfrom the [WebdriverIO example](webdriverio#spec), you notice a lot more code\nthat isn't tests, as we have to set up a few more WebDriver related items. ##\nRunning the Test Suite Now that we are all set up with our dependencies and our\ntest script, let's run it! ```sh npm test ``` ```sh yarn test ``` We should see\noutput the following output: ```text ➜ selenium git:(main) ✗ yarn test yarn run\nv1.22.11 $ Mocha Hello Tauri ✔ should be cordial (120ms) ✔ should be excited ✔\nshould be easy on the eyes 3 passing (588ms) Done in 0.93s. ``` We can see that\nour `Hello Tauri` sweet we created with `decribe` had all 3 items we created\nwith `it` pass their tests! With [Selenium] and some hooking up to a test suite,\nwe just enabled e2e testing without modifying our Tauri application at all!\n[Selenium]: https://selenium.dev/ [finished example project]:\nhttps://github.com/chippers/hello_tauri [example Application setup]: setup\n[Mocha]: https://mochajs.org/ [Chai]: https://www.chaijs.com/\n[`selenium-webdriver`]: https://www.npmjs.com/package/selenium-webdriver","url":"https://tauri.studio/docs/testing/webdriver/example/selenium"},{"id":"prose_docs_testing_webdriver_example_setup_md","title":"Setup Example","area":"testing","parentSection":"webdriver","section":"example","headings":["Initializing a Cargo Project","Creating a Minimal Frontend","Adding Tauri to the Cargo Project","Tauri Configuration","Running the Example Application"],"subHeadings":[],"code":["html","toml","rust","json"],"text":"HELLO, TAURI!","url":"https://tauri.studio/docs/testing/webdriver/example/setup"},{"id":"prose_docs_testing_webdriver_example_webdriverio_md","title":"WebdriverIO","area":"testing","parentSection":"webdriver","section":"example","headings":["Create a Directory for the Tests","Initializing a WebdriverIO Project","Config","Spec","Running the Test Suite"],"subHeadings":[],"code":["sh","text"],"text":"import Tabs from '@theme/Tabs' import TabItem from '@theme/TabItem' #\nWebdriverIO :::info Example Application This [WebdriverIO] guide expects you to\nhave already gone through the [example Application setup] to follow\nstep-by-step. The general information may still be helpful otherwise. ::: This\nWebDriver testing example will use [WebdriverIO], and its testing suite. It is\nexpected to have Node.js already installed, along with `npm` or `yarn` although\nthe [finished example project] uses `yarn`. ## Create a Directory for the Tests\nLet's create a space to write these tests in our project. We will be using a\nnested directory for this example project as we will later also go over other\nframeworks, but typically you only need to use one. Create the directory we will\nuse with `mkdir -p webdriver/webdriverio`. The rest of this guide assumes you\nare inside the `webdriver/webdriverio` directory. ## Initializing a WebdriverIO\nProject We will be using a pre-existing `package.json` to bootstrap this test\nsuite because we have already chosen specific [WebdriverIO] config options and\nwant to showcase a simple working solution. The bottom of this section has a\ncollapsed guide on setting it up from scratch. `package.json`: ```json { \"name\":\n\"webdriverio\", \"version\": \"1.0.0\", \"private\": true, \"scripts\": { \"test\": \"wdio\nrun wdio.conf.js\" }, \"dependencies\": { \"@wdio/cli\": \"^7.9.1\" },\n\"devDependencies\": { \"@wdio/local-runner\": \"^7.9.1\", \"@wdio/mocha-framework\":\n\"^7.9.1\", \"@wdio/spec-reporter\": \"^7.9.0\" } } ``` We have a script that runs a\n[WebdriverIO] config as a test suite exposed as the `test` command. We also have\nvarious dependencies added by the `@wdio/cli` command when we first set it up.\nIn short, these dependencies are for the most simple setup using a local\nWebDriver runner, [Mocha] as the test framework, and a simple Spec Reporter.\nClick me if you want to see how to set a project up from scratch The CLI is\ninteractive, and you may choose the tools to work with yourself. Note that you\nwill likely diverge from the rest of the guide, and you need to set up the\ndifferences yourself. Let's add the [WebdriverIO] CLI to this npm project. ```sh\nnpm install @wdio/cli ``` ```sh yarn add @wdio/cli ``` To then run the\ninteractive config command to set up a [WebdriverIO] test suite, you can then\nrun: ```sh npx wdio config ``` ```sh yarn wdio config ``` ## Config You may have\nnoticed that the `test` script in our `package.json` mentions a file\n`wdio.conf.js`. That's the [WebdriverIO] config file which controls most aspects\nof our testing suite. `wdio.conf.js`: ```js const os = require(\"os\"); const path\n= require(\"path\"); const { spawn, spawnSync } = require(\"child_process\"); //\nkeep track of the `tauri-driver` child process let tauriDriver; exports.config =\n{ specs: [\"./test/specs/**/*.js\"], maxInstances: 1, capabilities: [ {\nmaxInstances: 1, \"tauri:options\": { application:\n\"../../target/release/hello-tauri-webdriver\", }, }, ], reporters: [\"spec\"],\nframework: \"mocha\", mochaOpts: { ui: \"bdd\", timeout: 60000, }, // ensure the\nrust project is built since we expect this binary to exist for the webdriver\nsessions onPrepare: () => spawnSync(\"cargo\", [\"build\", \"--release\"]), // ensure\nwe are running `tauri-driver` before the session starts so that we can proxy the\nwebdriver requests beforeSession: () => (tauriDriver = spawn(\npath.resolve(os.homedir(), \".cargo\", \"bin\", \"tauri-driver\"), [], { stdio: [null,\nprocess.stdout, process.stderr] } )), // clean up the `tauri-driver` process we\nspawned at the start of the session afterSession: () => tauriDriver.kill(), };\n``` If you are interested in the properties on the `exports.config` object, I\n[suggest reading the documentation][WebDriver documentation]. For non-WDIO\nspecific items, there are comments explaining why we are running commands in\n`onPrepare`, `beforeSession`, and `afterSession`. We also have our specs set to\n`\"./test/specs/**/*.js\"`, so let's create a spec now. ## Spec A spec contains\nthe code that is testing your actual application. The test runner will load\nthese specs and automatically run them as it sees fit. Let's create our spec now\nin the directory we specified. `test/specs/example.e2e.js`: ```js // calculates\nthe luma from a hex color `#abcdef` function luma(hex) { if\n(hex.startsWith(\"#\")) { hex = hex.substring(1); } const rgb = parseInt(hex, 16);\nconst r = (rgb >> 16) & 0xff; const g = (rgb >> 8) & 0xff; const b = (rgb >> 0)\n& 0xff; return 0.2126 * r + 0.7152 * g + 0.0722 * b; } describe(\"Hello Tauri\",\n() => { it(\"should be cordial\", async () => { const header = await $(\"body >\nh1\"); const text = await header.getText(); expect(text).toMatch(/^[hH]ello/);\n}); it(\"should be excited\", async () => { const header = await $(\"body > h1\");\nconst text = await header.getText(); expect(text).toMatch(/!$/); }); it(\"should\nbe easy on the eyes\", async () => { const body = await $(\"body\"); const\nbackgroundColor = await body.getCSSProperty(\"background-color\");\nexpect(luma(backgroundColor.parsed.hex)).toBeLessThan(100); }); }); ``` The\n`luma` function on top is just a helper function for one of our tests and is not\nrelated to the actual testing of the application. If you are familiar with other\ntesting frameworks, you may notice similar functions being exposed that are\nused, such as `describe`, `it`, and `expect`. The other APIs, such as items like\n`$` and its exposed methods, are covered by the [WebdriverIO API docs]. ##\nRunning the Test Suite Now that we are all set up with config and a spec let's\nrun it! ```sh npm test ``` ```sh yarn test ``` We should see output the\nfollowing output: ```text ➜ webdriverio git:(main) ✗ yarn test yarn run v1.22.11\n$ wdio run wdio.conf.js Execution of 1 workers started at\n2021-08-17T08:06:10.279Z [0-0] RUNNING in undefined - /test/specs/example.e2e.js\n[0-0] PASSED in undefined - /test/specs/example.e2e.js \"spec\" Reporter:\n------------------------------------------------------------------ [wry 0.12.1\nlinux #0-0] Running: wry (v0.12.1) on linux [wry 0.12.1 linux #0-0] Session ID:\n81e0107b-4d38-4eed-9b10-ee80ca47bb83 [wry 0.12.1 linux #0-0] [wry 0.12.1 linux\n#0-0] » /test/specs/example.e2e.js [wry 0.12.1 linux #0-0] Hello Tauri [wry\n0.12.1 linux #0-0] ✓ should be cordial [wry 0.12.1 linux #0-0] ✓ should be\nexcited [wry 0.12.1 linux #0-0] ✓ should be easy on the eyes [wry 0.12.1 linux\n#0-0] [wry 0.12.1 linux #0-0] 3 passing (244ms) Spec Files: 1 passed, 1 total\n(100% completed) in 00:00:01 Done in 1.98s. ``` We see the Spec Reporter tell us\nthat all 3 tests from the `test/specs/example.e2e.js` file, along with the final\nreport `Spec Files: 1 passed, 1 total (100% completed) in 00:00:01`. Using the\n[WebdriverIO] test suite, we just easily enabled e2e testing for our Tauri\napplication from just a few lines of configuration and a single command to run\nit! Even better, we didn't have to modify the application at all. [WebdriverIO]:\nhttps://webdriver.io/ [finished example project]:\nhttps://github.com/chippers/hello_tauri [example Application setup]: setup\n[Mocha]: https://mochajs.org/ [WebDriver documentation]:\nhttps://webdriver.io/docs/configurationfile [WebdriverIO API docs]:\nhttps://webdriver.io/docs/api","url":"https://tauri.studio/docs/testing/webdriver/example/webdriverio"}]